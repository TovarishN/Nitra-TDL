using DotNet;

using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Utility.Pair;

using System;
using System.IO;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Text;
using System.Linq;

using Nemerle;
using Nemerle.Extensions;

using Nitra.Declarations;

using Tdl;
using QuickType;
using Tdl2Json.ExceptionHelper;

namespace Tdl2Json
{
  public module Deployments
  {
    public Generate(symbols : IEnumerable[DeclarationSymbol], deploymentScriptHeader : string, deploymentToolPath : string) : Dictionary[string, QuickType.Deployment]
    {
      def result = Dictionary();
      // выбрасываем неиспользованный Empty-деплоймент
      foreach (d is DeploymentSymbol when !(d is Deployment.EmptySymbol) || (d.IsIsUsedEvaluated && d.IsUsed) in symbols)
        GenerateDeployment(d, deploymentScriptHeader, deploymentToolPath, result);
      result
    }

    public IsDeploymentCodeParameter(symbol : DotNet.TypedDeclarationSymbol) : bool
    {
      | s is DotNet.FormalParameterSymbol when s.IsDeclaredInEvaluated => s.DeclaredIn is Deployment.CodeSymbol
      | _ => false
    }

    public GetParameterValue(parameter : DotNet.FormalParameterSymbol) : object
    {
      match (parameter.Default)
      {
        | Reference as r => "#(" + r.name + ")"
        | None           
        | String   
        | Bool     
        | Number   
        | Decimal  
        | Double   
        | Single => "$(" + parameter.Name + ")"
        | _              => throw NotSupportedException($"$(parameter.Default.GetType().Name) is not supported in deployment parameters")
      }
    }

    public GetDefaultValue(parameter : DotNet.FormalParameterSymbol) : object
    {
      match (parameter.Default)
      {
        | String    as s => s.Value
        | Bool      as b when IsDeploymentCodeParameter(parameter) => if (b.Value) 1 else 0
        | Bool      as b => b.Value
        | Number    as n => n.Value
        | Decimal   as d => d.Value
        | Double    as d => d.Value
        | Single    as s => s.Value
        | None           => null
        | Reference as r => r.name
        | _              => throw NotSupportedException($"$(parameter.Default.GetType().Name) is not supported in deployment parameters")
      }
    }
    
    private GenerateDeploymentScript(script : Deployment.ScriptSymbol, result : Dictionary[string, QuickType.Deployment]) : void
    {
      def refDefs          = HashSet(script.Defs.Where(d => d.Expr is Expr.Reference).Select(d => (d.Expr :> Expr.Reference).Symbol.Name));
      def simpleParameters = script.Parameters.Where(p => !(p.Type is Tdl.ProductTypeSymbol)).ToArray();
      def parameters       = simpleParameters.Select(p => (p.Name, GetParameterValue(p)));
      def defaultes        = script.Parameters.Select(p => (p.Name, GetDefaultValue(p))).Where(((_, d)) => d != null).ToDictionary();
      def defs             = script.Defs.Select(d => (d.Name, d.Expr.ToObject(null)));
      def scriptArgs       = parameters.Where((p, _) => !refDefs.Contains(p)).Concat(defs).ToDictionary();

      def deploymentModel = Deployment() <- 
      {
        Type                    = TypeEnum.Script;
        ReturnValue             = if (script.Expected.HasValue)    script.Expected.Value  else null;
        RebootExitCode          = if (script.ForReboot.HasValue)   script.ForReboot.Value else null;
        Timeout                 = if (script.Timeout.HasValue)     script.Timeout.Value   else null;
        ScriptArgs              = scriptArgs;
        ScriptArgsDefaultValues = defaultes;
      };

      if (script.IsEmbedPathEvaluated)
      {
        def fileName                        = script.EmbedPath.Value;
        deploymentModel.ScriptData          = File.ReadAllBytes(fileName);
        deploymentModel.ScriptDataExtension = Path.GetExtension(fileName);
      }
      else
      {
        deploymentModel.ScriptPath          = if (script.IsPathEvaluated)      script.Path.Value      else null;
        deploymentModel.ScriptData          = if (script.IsBase64Evaluated)    script.Base64.Value    else null;
        deploymentModel.ScriptDataExtension = if (script.IsExtensionEvaluated) script.Extension.Value else null;
      }

      result.Add(script.Name, deploymentModel)
    }

    private GenerateDeploymentSelect(sel : Deployment.SelectSymbol, deploymentScriptHeader : string, deploymentToolPath : string, result : Dictionary[string, QuickType.Deployment]) : void
    {
      def separator = "⁞";
      def deployments = sel.Deployments;
      def cases       = sel.Cases;
      assert2(deployments.Length == cases.Length);
      def condition   = string.Join(separator, sel.Parameters.Select(p => "$(" + p.Name + ")"));
      def values      = Dictionary();
      for (mutable i; i < deployments.Length; ++i)
      {
        def selector = string.Join(separator, cases[i].Select(v => v ?? JsonGenerator.ParameterDefaultValue));
        def seq      = deployments[i];
        mutable name;
        if (seq.Length == 1)
          name = seq[0].Name
        else
        {
          name = sel.Name + separator + selector;
          GenerateDeploymentSequence(name, seq, deploymentScriptHeader, deploymentToolPath, result);
        }
        values.Add(selector, name)
      }

      result.Add(sel.Name, 
        Deployment() <- 
        { 
            Type      = TypeEnum.Select;
            Condition = condition;
            Values    = values;
        })
    }

    private GenerateDeploymentCurrying(currying : Deployment.CurryingSymbol, result : Dictionary[string, QuickType.Deployment]) : void
    {
      def deployments = Dictionary();
      deployments.Add(currying.BaseDeployment.Name, currying.ParameterValues.ToDictionary(p => p.Symbol.Name, p => p.Expr.ToObject(p.Symbol)));
      result.Add(currying.Name,
        Deployment() <-
        {
            Type        = TypeEnum.Sequence;
            Deployments = array[deployments];
        })
    }

    private GenerateDeploymentCode(code : Deployment.CodeSymbol, deploymentScriptHeader : string, deploymentToolPath : string, result : Dictionary[string, QuickType.Deployment]) : void
    {
      def deployment = DeploymentCodeCompiler(code).Compile(deploymentScriptHeader, deploymentToolPath);
      result.Add(code.Name, deployment)
    }

    private GenerateDeployment(deploymentSymbol : DeploymentSymbol, deploymentScriptHeader : string, deploymentToolPath : string, result : Dictionary[string, QuickType.Deployment]) : void
    {
      match (deploymentSymbol)
      {
        | Deployment.ScriptSymbol   as script   => GenerateDeploymentScript(script, result)
        | Deployment.CurryingSymbol as currying => GenerateDeploymentCurrying(currying, result)
        | Deployment.CodeSymbol     as code     => GenerateDeploymentCode(code, deploymentScriptHeader, deploymentToolPath, result)
        | Deployment.SetSymbol      as set      => GenerateDeploymentSequence(set.Name, set.Deployments, deploymentScriptHeader, deploymentToolPath, result)
        | DeploymentRebootSymbol as reboot => 
          result.Add(reboot.Name, 
            Deployment() <-
            {
              Type          = TypeEnum.Reboot;
              RebootTimeout = if (reboot.Timeout.HasValue) reboot.Timeout.ValueOrDefault else "00:30:00";
            })

        | Deployment.SelectSymbol as sel => GenerateDeploymentSelect(sel, deploymentScriptHeader, deploymentToolPath, result)
        | Deployment.EmptySymbol as empty => result.Add(empty.Name, Deployment() <- { Type = TypeEnum.Empty })
        | _ => _ = ThrowNotSupportedSymbol(deploymentSymbol)
      }
    }

    private GenerateDeploymentSequence(name : string, sequence : ImmutableArray[DeploymentSymbol], deploymentScriptHeader : string, deploymentToolPath : string, result : Dictionary[string, QuickType.Deployment]) : void
    {
      match (NList.ToList(OptimizeDeploymentSequence(sequence)))
      {
        | [OptimizedDeployments.Compiler(builder)] => result.Add(name, builder.Compile(deploymentScriptHeader, deploymentToolPath, name))
        | lst =>
          def names = List();

          foreach (x in lst)
          {
            | OptimizedDeployments.Compiler(builder) =>
              unless (result.ContainsKey(builder.Name))
                result.Add(builder.Name, builder.Compile(deploymentScriptHeader, deploymentToolPath));
              names.Add(builder.Name);

            | OptimizedDeployments.Range(start, count) =>
              def end = start + count;
              for (mutable i = start; i < end; ++i)
                names.Add(sequence[i].Name);
          }

          result.Add(name, Deployment() <- 
          { 
            Type        = TypeEnum.Sequence;
            Deployments = names.ToArray()
          })
      }
    }

    private variant OptimizedDeployments
    {
      | Range    { start : int; count : int; }
      | Compiler { builder : DeploymentCodeCompiler; }
    }

    private OptimizeDeploymentSequence(deployments : ImmutableArray[DeploymentSymbol]) : Seq[OptimizedDeployments]
    {
      mutable start;
      mutable pos;

      while (pos < deployments.Length)
      {
        if (deployments[pos] is Deployment.CodeSymbol as first)
        {
          def builder = DeploymentCodeCompiler(first);

          def fold()
          {
            ++pos;
            when (pos < deployments.Length)
            when (deployments[pos] is Deployment.CodeSymbol as next)
            when (builder.TryAdd(next))
              fold();
          }
          fold();

          when (builder.Count > 1)
          {
            def count = pos - start - builder.Count;
            when (count > 0)
              yield OptimizedDeployments.Range(start, count);

            yield OptimizedDeployments.Compiler(builder);
            start = pos;
          }
        }
        else
          ++pos
      }

      def count = pos - start;
      when (count > 0)
        yield OptimizedDeployments.Range(start, count);
    }
  } // module
} // namespace
