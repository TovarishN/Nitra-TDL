using DotNet;

using JsonDal;

using Microsoft.Cci.MetadataReader.ObjectModelImplementation;

using Nemerle;
using Nemerle.Assertions;
using Nemerle.Collections;
using Nemerle.Extensions;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Utility.Pair;

using Newtonsoft.Json;

using Nitra;
using Nitra.BackEnd.Cci;
using Nitra.Declarations;
using Nitra.ProjectSystem;

using Microsoft.Cci;

using QuickType;
using Utils;

using System;
using System.Globalization;
using System.Text;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Threading;

using Tdl;
using Tdl2Json.ExceptionHelper;

// Сгенерированно с помощью: https://app.quicktype.io/
namespace Tdl2Json
{
  public delegate TransfomationFunc(context : TransformationContext) : void;
  public delegate MessageHandler(text : string, importance : MessageImportance) : void;

  public enum MessageImportance
  {
    | Low
    | High
  }

  public module JsonGenerator
  {
    public ParameterDefaultValue = "C3EEBA2A-D830-4947-83B2-045529DCB327";
    
    static JsonVersion : int = 7;
    public IsExperimental = ThisAssembly.BranchName != "master";

    public event OnMessage : MessageHandler;

    public Generate(
      [NotNullOrEmpty] workingDirectory         : string,
      [NotNull]        sourceFiles              : array[string],
      [NotNull]        references               : array[string],
                       deploymentScriptHeader   : string,
               mutable deploymentToolPath       : string,
                       isMethodTypingEnabled    : bool,
                       output                   : Lazy[TextWriter],
                       transformatorOutput      : string,
                       transformatorOpt         : TransfomationFunc,
                       isTestMode               : bool,
                       jsonSchemaType           : string
      ) : TransformationContext
    {
      def mode =
        match (isTestMode)
        {
          | true                             => CompilerMode.Test
          | _  when transformatorOpt != null => CompilerMode.Transform
          | _                                => CompilerMode.Compile
        };
      def absolutePaths = sourceFiles.Map(f => if(Path.IsPathRooted(f)) f else Path.Combine(workingDirectory, f));

      def CheckFilesExists(files, messageformatter : string -> string)
      {
        def notFoundFiles = files.Where(f => !File.Exists(f)).ToList();
        when (notFoundFiles.Any())
        {
          def messages = notFoundFiles.Select(messageformatter).ToArray();
          throw ConfigurationException(string.Join("\r\n", messages));
        }
      }

      CheckFilesExists(absolutePaths, m => $"File not found: $m");

      def context = Compile(workingDirectory, absolutePaths, references, isMethodTypingEnabled, mode, transformatorOutput);
      unless (context.Messages.HasErrors)
      {
        if (mode == CompilerMode.Transform)
          transformatorOpt(context);
        else
        {
          when (string.IsNullOrEmpty(deploymentToolPath))
            deploymentToolPath = <#.\KL.Autotests.Deployer.exe#>;

          GenerateJson(context.RootNamespace, context.InitialDeployment, output, deploymentScriptHeader, deploymentToolPath, jsonSchemaType);
        }
      }

      context
    }

    private static StandardLibraries : array[LibReference] = array[
      FullNameLibReference("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"),
      FullNameLibReference("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"),
      FullNameLibReference("System.Core, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")
    ];

    private Compile(directory : string, files : array[string], refs : array[string], isMethodTypingEnabled : bool, mode : CompilerMode, transformatorOutput : string) : TransformationContext
    {
      TdlTypingSettings.IsMethodTypingEnabled = isMethodTypingEnabled;
      
      def commentBag     = if (mode == CompilerMode.Compile) null else CommentBag();
      def solution       = FsSolution();
      def project        = FsProject(solution, 
                                     directory, 
                                     files.Map(FsFileWithId(_, TdlLang.Instance, commentBag)),
                                     StandardLibraries.Concat(refs.Select(FileLibReference)).ToArray());
      def stopwatch      = Stopwatch.StartNew();
      def projectSupport = ProjectSupport(testMode=true);
      ReportMessage("Loading types from referenced assemblies...");
      def data           = projectSupport.RefreshReferences(CancellationToken.None, project);
      ReportElapsedTime(stopwatch);

      ReportMessage("Parsing TDLs...");
      project.Data       = data;
      def files          = project.Files.Select(_.GetEvalPropertiesData()).ToImmutableArray();
      ReportElapsedTime(stopwatch);

      ReportMessage("Semantic analysis...");
      projectSupport.RefreshProject(CancellationToken.None, files, data);
      ReportElapsedTime(stopwatch);

      def messages = CompilerMessageBag(project.CompilerMessages :> CompilerMessageList);

      foreach (file when file.HasCompilerMessage in files)
        _ = messages.AddRange(file.GetCompilerMessage());

      foreach (file in project.Files)
        _ = messages.AddRange(file.GetCompilerMessages());

      def tdlProjectData = data :> TdlProjectData;
      def evalContext    = tdlProjectData.Context :> TdlDependentPropertyEvalContext;
      TransformationContext(tdlProjectData.RootNamespace, commentBag, messages, evalContext.InitialDeployment, transformatorOutput)
    }

    internal ReportMessage(msg : string, importance : MessageImportance = MessageImportance.High) : void
    {
      OnMessage?.Invoke(msg, importance);
    }

    private ReportElapsedTime(stopwatch : Stopwatch) : void
    {
      ReportMessage($"Elapsed time: $(stopwatch.Elapsed)");
      stopwatch.Restart();
    }

    private GenerateJson(root : NamespaceSymbol, initialDeployment : DeploymentSymbol, output : Lazy[TextWriter], deploymentScriptHeader : string, deploymentToolPath : string, mutable jsonSchemaType : string) : void
    {
      def stopwatch = Stopwatch.StartNew();
      JsonGenerator.ReportMessage("Generating JSON...");

      when (string.IsNullOrEmpty(jsonSchemaType))
        jsonSchemaType = if (IsExperimental) "dev" else "prod";

      def symbols     = root.MemberTable.Symbols.SelectMany(x => x).ToImmutableArray();
      def suites      = List();
      def suiteGroups = List();
      foreach (g is Suite.GeneratorSymbol in symbols)
        GenerateSuiteGenerator(g, suites, suiteGroups);

      def suiteGroups = symbols.OfType.[Suite.ListSymbol]().Select(GenerateSuiteGroup).Concat(suiteGroups).ToDictionary();
        
      def coordinate = Root() <-
      {
        Version       = JsonVersion;
        Schema        = $<#http://auto-reports.avp.ru/starter-schema/v$JsonVersion/$jsonSchemaType/schema.json#>;
        Deployments   = Deployments.Generate(symbols, deploymentScriptHeader, deploymentToolPath);
        Products      = symbols.OfType.[ProductSymbol        ]().Select(GenerateProduct)             .ToDictionary();
        Platforms     = symbols.OfType.[PlatformSymbol       ]().Select(GeneratePlatform)            .ToDictionary();
        Suites        = symbols.OfType.[Suite.DefSymbol      ]().Select(GenerateSuite).Concat(suites).ToDictionary();
        TestScenarios = symbols.OfType.[Tdl.ScenarioSymbol   ]().SelectMany(GenerateScenarios(_, initialDeployment)).ToDictionary();
        SuiteGroups   = if (suiteGroups.Count == 0) null else suiteGroups;
        TestEntities  = symbols.OfType.[EntitySymbol         ]().Select(GenerateEntity)              .ToDictionary();
      };

      def settings = ConverterSettings.Settings <- Formatting = Formatting.Indented;
      def serializer = JsonSerializer.Create(settings);
      serializer.Serialize(output.Value, coordinate);
      output.Value.Flush();

      ReportElapsedTime(stopwatch);
    }

    private GeneratePlatform(platformSymbol : PlatformSymbol) : string * PlatformValue
    {
      | Platform.DefSymbol as Def => (Def.Name, PlatformValue() <- { Platform    = Platform() })
      | Platform.SetSymbol as Set => (Set.Name, PlatformValue() <- { StringArray = Set.Platforms.Select(_.Name).ToArray(); });
      | _                         => ThrowNotSupportedSymbol(platformSymbol)
    }

    toJson(expr : Tdl.Expr, dic : Dictionary[TypedDeclarationSymbol, Tdl.Expr]) : object
    {
      match (expr)
      {
        | String    as str => str.Value
        | False            => false
        | True             => true
        | Real      as x   => x.Value
        | Integer   as x   => x.Value
        | Reference(Symbol=VarSymbol as v) => toJson(dic[v], dic)
        | Reference(Symbol=TypedDeclarationSymbol(Type=ProductTypeSymbol) as s) => /*"Product:" +*/ s.Name
        | Reference(Symbol=FieldSymbol(DeclaredIn=ExternalSymbol) as fld) => $"#($(fld.Name))"
        | Reference as x   => "#(" + x.Symbol.Name + ")"
        | Error     as e   => throw NotSupportedException("Error at: " + e.Location);
        | List      as xs  => xs.Elems.Select(toJson(_, dic)).ToArray()
        | x                => throw NotSupportedException("The '" + x + "' is not supported");
      }
    }
      
    private CollectDefs(defs : Seq[Def], dic : Dictionary[TypedDeclarationSymbol, Tdl.Expr] = null) : Seq[string * object]
    {
      foreach(@def in defs)
      {
        def name = @def.Symbol.Name;
        yield (name, toJson(@def.Expr, dic));
      }
    }

    private GenerateProduct(productSymbol : ProductSymbol) : string * ProductValue
    {
      | Product.DefSymbol as Def => 
        def parameters = CollectDefs(Def.Defs).ToDictionary();
        def useAsFixedParameter(name : string) : string
        {
          mutable value;
          if (parameters.TryGetValue(name, out value))
          {
            _ = parameters.Remove(name);
            value :> string
          }
          else
            null
        }
        def name = useAsFixedParameter("Name");
        parameters.Add("Name", name);
        (Def.Name, 
          ProductValue() <- 
          {
            Product = Product() <- { 
              Name              = name;
              BranchName = useAsFixedParameter("ReleaseName") ?? useAsFixedParameter("BranchName"); // 
              Version           = useAsFixedParameter("Version");
              DumpServerProduct = useAsFixedParameter("DumpServerProduct");
              Parameters  = parameters;
              Parameters        = parameters;
            }
          })
      | Product.SetSymbol as Set => (Set.Name, ProductValue() <- { StringArray = Set.AllProducts.Select(p => p.Name).ToArray(); })   
      | _ => ThrowNotSupportedSymbol(productSymbol)
    }

    private GetAssemblyAndMethodName(typeSymbolOpt : DeclarationSymbol, [NotNull] methodSymbol : Member.MethodSymbol) : string * string
    {
      def decl         = methodSymbol.GetDeclarationsOfType.[ExternalMethodDeclaration]();
      def method       = decl.First().Method;
      def typeSymbol   = typeSymbolOpt :> SymbolBase;
      def type         = if (typeSymbol == null) method.ContainingType :> ITypeDefinition
                         else typeSymbol.GetDeclarationsOfType.[ExternalTopTypeDeclaration.[TopClassSymbol]]().First().Type;
      def unit         = TypeHelper.GetDefiningUnit(type);
      def assemblyName = unit.Name.Value + ".dll";
      def methodName   = type + "." + method.Name.Value;

      (assemblyName, methodName)
    }

    private SubstituteVariables(froms : ImmutableArray[Code.From], index : int = 0) : Seq[Dictionary[TypedDeclarationSymbol, Tdl.Expr]]
    {
      if (index < froms.Length)
      {
        def from = froms[index];
        foreach (dictionary in SubstituteVariables(froms, index + 1))
        {
          foreach (expr in from.Elems.GetExprList())
          {
            | Expr.Tuple as t =>
              foreach (var in from.Vars with i)
                dictionary[var] = t.Elems[i];
              yield dictionary;

            | _ =>
              assert2(from.Vars.Length == 1);
              def var = from.Vars[0];
              dictionary[var] = expr;
              yield dictionary;
          }
        }
      }
      else
        yield Dictionary();
    }
    
    TryResolveVar[T](dic : Dictionary[TypedDeclarationSymbol, Tdl.Expr], varOrSymbol : TypedDeclarationSymbol) :  T
      where T: DeclarationSymbol
    {
      mutable result;
      if (dic.TryGetValue(varOrSymbol, out result))
      {
        if (result is Tdl.Expr.Reference as r)
          r.Symbol :> T
        else if (result is Tdl.Expr.MemberAccess as m)
          m.Symbol :> T
        else
          result.GetValue() :> T
      }
      else
        varOrSymbol :> T
    }
    
    GetFixedString(g : Tdl.Scenario.GeneratorSymbol, name : string) : string
    {
      g.Defs.Find(d => d.Symbol.Name == name).Map(_.Expr).Map(expr => (expr :> Tdl.Expr.String).Value).WithDefault(null);
    }
    
    private GenerateScenarios(scenarioSymbol : ScenarioSymbol, initialDeployment : DeploymentSymbol) : Seq[string * TestCase]
    {
      mutable counter : uint = 0;
      match(scenarioSymbol)
      {
        | Tdl.Scenario.GeneratorSymbol as g =>
          def incGuid(guid : Guid) : Guid
          {
            def bytes1   = guid.ToByteArray();
            def version  = BitConverter.ToUInt32(bytes1, 0) + counter;
            def bytes2   = BitConverter.GetBytes(version);
            bytes1[0] = bytes2[0];
            bytes1[1] = bytes2[1];
            bytes1[2] = bytes2[2];
            bytes1[3] = bytes2[3];
            Guid(bytes1)
          }
          mutable uniqueId = Guid.Parse(GetFixedString(g, "UniqueId"));
          def names = List();
          foreach (dic in SubstituteVariables(g.Froms, 0))
          {
            counter++;
            def name = scenarioSymbol.Name + "-" + counter;
            names.Add(name);
            def testGroup = GenerateSuite(g, uniqueId, dic, initialDeployment);
            yield (name, TestCase() <- { TestGroup = testGroup; });
            uniqueId = incGuid(uniqueId);
          }
              
          yield (scenarioSymbol.Name, TestCase() <- { TestGroup = TestGroup() <- { TestScenarios = names.ToArray() }; });

        | _ => yield GenerateScenario(scenarioSymbol, initialDeployment);
      }
    }

    private GenerateSuite(g : Tdl.Scenario.GeneratorSymbol, uniqueId : Guid, dic : Dictionary[TypedDeclarationSymbol, Tdl.Expr], initialDeployment : DeploymentSymbol) : TestGroup
    {
      def getString(name : string) : string
      {
        def getValue(expr : Tdl.Expr) : string
        {
          | String as s => s.Value
          | Reference(Symbol=VarSymbol as v) => getValue(dic[v])
          | Reference(Symbol=FieldSymbol(DeclaredIn=ExternalSymbol) as fld) => $"#($(fld.Name))"
          | _ => throw NotSupportedException($"$expr ($(expr.GetType().Name))")
        }
        g.Defs.Find(d => d.Symbol.Name == name).Map(d => getValue(d.Expr)).WithDefault(null);
      }
      def getBool(name : string) : bool?
      {
        def getValue(expr : Tdl.Expr) : bool?
        {
              | Tdl.Expr.True  => Nullable(true)
              | Tdl.Expr.False => Nullable(false)
              | Reference(Symbol=VarSymbol as v) => getValue(dic[v])
              | _              => throw NotSupportedException($"$expr ($(expr.GetType().Name))")
        }
        g.Defs.Find(d => d.Symbol.Name == name).Map(_.Expr).Map(getValue).WithDefault(null);
      }
      def getLong(name : string) : long?
      {
          def getValue(expr : Tdl.Expr) : long?
          {
            | Integer as s => s.Value
            | Reference(Symbol=VarSymbol as v) => getValue(dic[v])
            | _ => throw NotSupportedException($"$expr ($(expr.GetType().Name))")
          }
          g.Defs.Find(d => d.Symbol.Name == name).Map(_.Expr).Map(getValue).WithDefault(null);
      }
      def getInt(name : string) : int?
      {
          def getValue(expr : Tdl.Expr) : int?
          {
            | Integer as s => s.Value
            | Reference(Symbol=VarSymbol as v) => getValue(dic[v])
            | _ => throw NotSupportedException($"$expr ($(expr.GetType().Name))")
          }
          g.Defs.Find(d => d.Symbol.Name == name).Map(_.Expr).Map(getValue).WithDefault(null);
      }
      def deployment = TryResolveVar(dic, g.Deployment) : DeploymentSymbol;
      def method     = TryResolveVar(dic, g.Method)     : Member.MethodSymbol;
      def platform   = TryResolveVar(dic, g.Platform)   : PlatformSymbol;
      def product    = TryResolveVar(dic, g.Product)    : ProductSymbol;
      def getTestMethod() : TestMethod
      {
        def (assemblyName, methodName) = GetAssemblyAndMethodName(null, method);
        TestMethodQualifier() <- 
        {
          AssemblyName = assemblyName;
          MethodName   = methodName;
        }
      }
      def testGroup =
        TestGroup() <- 
        {
          Deployments             = GetTestGroupDeployments(initialDeployment, deployment);
          Environments            = array[EnvironmentElement() <- { Platforms= array[platform.Name]; Products=array[product.Name]; }];
          TestMethod              = getTestMethod();
          Area                    = getString("Area");
          ExternalAutotestId      = getInt   ("ExternalAutotestId");
          LocalTestBinariesFolder = getString("LocalTestBinariesFolder");
          NeedUnsignedAgent       = getBool  ("NeedUnsignedAgent");
          RequireInternet         = getBool  ("RequireInternet");
          RerunCountOnTestFailure = getLong  ("RerunCountOnTestFailure");
          RerunCountOnTestSuccess = getLong  ("RerunCountOnTestSuccess");
          Responsible             = getString("Responsible");
          RevertAgentAfter        = getBool  ("RevertAgentAfter");
          RevertAgentBefore       = getBool  ("RevertAgentBefore");
          TfsId                   = getLong  ("TfsId");
          Timeout                 = getString("Timeout");
          UniqueId                = uniqueId.ToString();
          ProductGroupName        = getString("ProductGroupName");
          FilterExpression        = GenerateScenarioFilter(g.Filter :> DotNet.ExprBase, dic);
        };

      testGroup
    }

    private GenerateScenario(scenarioSymbol : ScenarioSymbol, initialDeployment : DeploymentSymbol) : string * TestCase
    {
      (scenarioSymbol.Name, 
        TestCase() <- {
          TestGroup = 
          match (scenarioSymbol)
          {
            | Tdl.Scenario.DefSymbol as r =>
              def r = r;
              def parallelSetOpt = if (r.IsParallelSetOptEvaluated) r.ParallelSetOpt else null;
              def barriersCount  = if (parallelSetOpt == null) Dictionary() 
                                   else parallelSetOpt.BarriersCount.ToDictionary();
              def getString(name : string) : string
              {
                r.Defs.Find(d => d.Symbol.Name == name).Map(_.Expr).Map(expr => (expr :> Tdl.Expr.String).Value).WithDefault(null);
              }
              def getBool(name : string) : bool?
              {
                r.Defs.Find(d => d.Symbol.Name == name).Map(_.Expr)
                  .Map(fun(expr)
                    {
                      | Tdl.Expr.True  => Nullable(true)
                      | Tdl.Expr.False => Nullable(false)
                      | _              => throw NotSupportedException()
                    })
                  .WithDefault(null);
              }
              def getLong(name : string) : long?
              {
                  r.Defs.Find(d => d.Symbol.Name == name).Map(_.Expr).Map(expr => Nullable((expr :> Tdl.Expr.Integer).Value)).WithDefault(null);
              }
              def getInt(name : string) : int?
              {
                  r.Defs.Find(d => d.Symbol.Name == name).Map(_.Expr).Map(expr => Nullable((expr :> Tdl.Expr.Integer).Value)).WithDefault(null);
              }
              def artifactsCollectionTimeout = getString("ArtifactsCollectionTimeout");
              def getTestMethod() : TestMethod
              {
                when (r.Actions.Length == 1)
                when (r.Actions[0] is ScenarioAction.Method as method)
                {
                  def (assemblyName, methodName) = GetAssemblyAndMethodName(method.type, method.method);
                  return TestMethodQualifier() <- 
                  {
                    AssemblyName               = assemblyName;
                    MethodName                 = methodName;
                    MaxRebootsCount            = method.MaxRebootsCountOpt.ToNulable();
                    ArtifactsCollectionTimeout = artifactsCollectionTimeout;
                    LocalTestBinariesFolder    = if (method.binariesFolderOpt.HasValue) method.binariesFolderOpt.Value else null;
                  };
                }
                def makeMethodAction(method : ScenarioAction.Method) : TestMethodQualifier
                {
                  def (assemblyName, methodName) = GetAssemblyAndMethodName(method.type, method.method);
                  TestMethodQualifier() <- 
                  {
                    AssemblyName               = assemblyName;
                    MethodName                 = methodName;
                    MaxRebootsCount            = method.MaxRebootsCountOpt.ToNulable();
                    ArtifactsCollectionTimeout = artifactsCollectionTimeout;
                    LocalTestBinariesFolder    = if (method.binariesFolderOpt.HasValue) method.binariesFolderOpt.Value else null;
                  }
                }
                def makeScriptAction(c : ScenarioAction.Script) : UnixScriptRunner
                {
                    def testScriptArgs = string.Join(" ", c.Arguments.Select(a => a.Value.ToLiteral()));
                    def env = c.Defs.Select(d => (d.Symbol.Name, d.Expr.ToObject(d.Symbol))).ToDictionary();
                    UnixScriptRunner() <-
                    {
                      TestScriptName             = c.Name.Value;
                      TestScriptArgs             = testScriptArgs;
                      Environment                = env;
                      MaxRebootsCount            = c.MaxRebootsCountOpt.ToNulable();
                      ArtifactsCollectionTimeout = artifactsCollectionTimeout;
                    }
                }
                def makeGTestAction(c : ScenarioAction.GTest) : GTestProgram
                {
                    def testScriptArgs = c.Arguments.MapToArray(a => a.Value);
                    GTestProgram() <-
                    {
                      ProgramName                = c.Name.Value;
                      Arguments                  = testScriptArgs;
                      MaxRebootsCount            = c.MaxRebootsCountOpt.ToNulable();
                      ArtifactsCollectionTimeout = artifactsCollectionTimeout;
                    }
                }
                def makeAndroidJavaAction(c : ScenarioAction.Apk) : AndroidJava
                {
                    AndroidJava() <-
                    {
                      AndroidTestContainer       = c.Name.Value;
                      TestFilter                 = c.FilterOpt.ValueOrDefault;
                      TestRunnerPath             = c.RunnerPath.ValueOrDefault;
                      MaxRebootsCount            = c.MaxRebootsCountOpt.ToNulable();
                    }
                }
                def makeConfigAction(c : ScenarioAction.Config) : TestBot
                {
                  TestBot() <-
                  {
                    TestConfigName             = c.path.Value;
                    MaxRebootsCount            = c.MaxRebootsCountOpt.ToNulable();
                    ArtifactsCollectionTimeout = artifactsCollectionTimeout;
                  }
                }
                def makeAction(action : ScenarioAction) : TestSequenceItem
                {
                  | Reboot             => RebootTestStep() <- { ForceReboot = RebootTestStep.Data() }
                  | Method        as m => makeMethodAction(m)
                  | WaitForReboot as x =>                   
                    WaitForRebootTestStep() <- 
                    {
                      WaitForReboot = 
                        WaitForRebootTestStep.Data() <-
                        {
                          RebootTimeout = if (string.IsNullOrEmpty(x.TimeSpan)) "00:05:00" else x.TimeSpan
                        };
                    }
                  | Barrier as barrier =>
                    def b = barrier.barrier;
                    WaitForBarrierTestStep() <-
                    {
                      WaitForBarrier = 
                        WaitForBarrierTestStep.Data() <- 
                        {
                          Id      = b.Guid;
                          Timeout = TimeSpan.Parse(b.Timeout.Value);
                          Count   = barriersCount.GetValue(b);
                        }
                    }
                  | Script as s        => makeScriptAction(s)
                  | Config as c        => makeConfigAction(c)
                  | GTest  as g        => makeGTestAction(g)
                  | Apk as a           => makeAndroidJavaAction(a)
                  | Login as login     => LoginTestStep() <- { Login = LoginTestStep.Data() <- { User = login.User.Value; Password = login.Password.Value } }
                  | Logoff             => LogoffTestStep() <- { Logoff = LogoffTestStep.Data() }
                  | LockWorkstation    => LockWorkstationTestStep() <- { LockWorkstation = LockWorkstationTestStep.Data() }
                  | _                  => assert(false, "Unsupported ScenarioAction: " + action)
                }
                
                if (r.Actions.Length == 1 && r.Actions[0] is ScenarioAction.Config)
                  makeConfigAction(r.Actions[0] :> ScenarioAction.Config)
                else if (r.Actions.Length == 1 && r.Actions[0] is ScenarioAction.Script)
                  makeScriptAction(r.Actions[0] :> ScenarioAction.Script)
                else if (r.Actions.Length == 1 && r.Actions[0] is ScenarioAction.GTest)
                  makeGTestAction(r.Actions[0] :> ScenarioAction.GTest)
                else if (r.Actions.Length == 1 && r.Actions[0] is ScenarioAction.Apk)
                  makeAndroidJavaAction(r.Actions[0] :> ScenarioAction.Apk)
                else
                  TestMethodSequence() <-
                  {
                    TestSequence               = r.Actions.Select(makeAction).ToArray();
                    ArtifactsCollectionTimeout = artifactsCollectionTimeout;
                  }
              }
              
              TestGroup() <- 
              {
                  Deployments             = GetTestGroupDeployments(initialDeployment, r.Deployment);
                  Environments            = r.Environments.MapToArray(env => EnvironmentElement() <- { Platforms= array[env.Platform.Name]; Products=array[env.Product.Name]; });
                  TestMethod              = getTestMethod();
                  Area                    = getString("Area");
                  LocalTestBinariesFolder = getString("LocalTestBinariesFolder");
                  ExternalAutotestId      = getInt   ("ExternalAutotestId");
                  NeedUnsignedAgent       = getBool  ("NeedUnsignedAgent");
                  RequireInternet         = getBool  ("RequireInternet");
                  RerunCountOnTestFailure = getLong  ("RerunCountOnTestFailure");
                  RerunCountOnTestSuccess = getLong  ("RerunCountOnTestSuccess");
                  Responsible             = getString("Responsible");
                  RevertAgentAfter        = getBool  ("RevertAgentAfter");
                  RevertAgentBefore       = getBool  ("RevertAgentBefore");
                  TfsId                   = getLong  ("TfsId");
                  Timeout                 = getString("Timeout");
                  UniqueId                = getString("UniqueId");
                  ProductGroupName        = getString("ProductGroupName");
                  FilterExpression        = GenerateScenarioFilter(r.Filter :> DotNet.ExprBase, ImmutableDictionary.Empty);
                  MultiMachineId          = if (parallelSetOpt == null) null else parallelSetOpt.MultiMachineId;
              }

            | Tdl.Scenario.SetSymbol as Set => TestGroup() <- { TestScenarios = Set.Scenarios.Select(_.Name).ToArray() }
            | _                             => ThrowNotSupportedSymbol(scenarioSymbol)
          }
      })
    }

    private GetTestGroupDeployments(initialDeployment : DeploymentSymbol, scenarioDeployment : DeploymentSymbol) : array[TestGroupDeployment]
    {
      def makeReference(d : DeploymentSymbol) { TestGroupDeployment() <- String = d.Name }

      if (initialDeployment != null && !initialDeployment.Equals(scenarioDeployment))
        array[makeReference(initialDeployment), makeReference(scenarioDeployment)]
      else
        array[makeReference(scenarioDeployment)]
    }

    private GenerateEntity(symbol : EntitySymbol) : string * TestEntity
    {
      def parameters = CollectDefs(symbol.Defs).ToDictionary();
      def entity = TestEntity() <-
      {
        BranchName = parameters["BranchName"].ToString();
        Name       = parameters["Name"      ].ToString();
        Type       = parameters["Type"      ].ToString();
        Version    = parameters["Version"   ].ToString();
      };
      
      (symbol.Name, entity)
    }

    private GenerateScenarioFilter() : string
    {
      null
    }
    
    private GenerateScenarioFilter(expr : DotNet.ExprBase, dic : IReadOnlyDictionary[TypedDeclarationSymbol, Tdl.Expr]) : string
    {
      def result = GenerateScenarioFilterImpl(expr, dic);
      result
    }

    private GenerateTdlExpr(expr : Tdl.Expr, dic : IReadOnlyDictionary[TypedDeclarationSymbol, Tdl.Expr]) : string
    {
      match (expr)
      {
        | Error                         => GenerateScenarioFilter()
        | String(null)                  => "null"
        | String(s)                     => $<#@"$(s.Replace("\"", "\"\""))"#>
        | True                          => "true"
        | False                         => "false"
        | Real(num)                     => num.ToString(CultureInfo.InvariantCulture)
        | Integer(num)                  => num.ToString(CultureInfo.InvariantCulture)
        | Reference(symbol)             => GenerateBySymbol(symbol, dic)
        | MemberAccess(expr, member, _) => GenerateTdlExpr(expr, dic) + "." + member.InitialName
        | Tuple(items, _) =>
          def args = items.Map(GenerateTdlExpr(_, dic));
          $<#(..$args)#>

        | List(items, type) =>
          def args = items.Map(GenerateTdlExpr(_, dic));
          $<#new $(type.FullName)[] { ..$args }#>
      }
    }

    private GenerateDefaultValue(value : DotNet.DefaultValue) : string
    {
      | Null                  => "null"
      | String(null)          => "null"
      | String(s)             => $<#@"$(s.Replace("\"", "\"\""))"#>
      | Bool(true)            => "true"
      | Bool(false)           => "false"
      | Number(num, true, _)  => num.ToString(CultureInfo.InvariantCulture)
      | Number(num, false, _) => unchecked(num :> long).ToString(CultureInfo.InvariantCulture)
      | Decimal(num)          => num.ToString(CultureInfo.InvariantCulture)
      | Double(num)           => num.ToString(CultureInfo.InvariantCulture)
      | Single(num)           => num.ToString(CultureInfo.InvariantCulture)
      | t                     => throw NotSupportedException($"$(t.GetType().Name) is not supported in scenario parameters")
    }

    private GenerateBySymbol(symbol : DeclarationSymbol, dic : IReadOnlyDictionary[TypedDeclarationSymbol, Tdl.Expr]) : string
    {
      mutable tdlExpr;
      match (symbol)
      {
        | FieldSymbol as fld =>
          match (fld.DeclaredIn)
          {
            | ExternalSymbol =>
              def type = fld.Type.FullName;
              def name = fld.Name;
              $<#(($type)externals["$name"])#>
  
            | _ => GenerateScenarioFilter()
          }
  
        | FormalParameterSymbol as p => 
          def type =
            match (p.Type)
            {
              | SuiteTypeSymbol => "TestSuite"
              | _ => p.Type.FullName
            };

          def name = p.Name; 
          def getValue =
            match (type)
            {
              | "System.Boolean" | "bool" => $<#System.Convert.ToBoolean(globals["$name"])#>
              | _                         => $<#($type)globals["$name"]#>
            };

          if (p.HasDefault())
          {
            def defaultValue = GenerateDefaultValue(p.Default);
            $<#(globals.ContainsKey("$name") ? $getValue : $defaultValue)#>
          }
          else
            $<#($getValue)#>
  
        | Member.MethodSymbol as m => m.Name
        | PlatformSymbol as p => $<#config.Platforms["$(p.Name)"]#>
        | ProductSymbol  as p => $<#config.Products["$(p.Name)"]#>
        | TypedDeclarationSymbol as s when dic.TryGetValue(s, out tdlExpr) => GenerateTdlExpr(tdlExpr, dic)
        | _ => GenerateScenarioFilter()
      }
    }

    public static ToFullNameString(symbol : TypeSymbol) : string
    {
      | DotNet.TopConstructedTypeSymbol as s =>
        def fullName = AstUtils.MakeFullName(s.TypeInfo.DeclaredInOpt, s.TypeInfo.Name, s.Args);
        fullName
        
      | _ => GenerateScenarioFilter()
    }
    
    private GenerateScenarioFilterImpl(expr : DotNet.ExprBase, dic : IReadOnlyDictionary[TypedDeclarationSymbol, Tdl.Expr]) : string
    {
      match (expr)
      {
        | null => null
        | Expr.Is as e => $<#($(GenerateScenarioFilterImpl(e.Expr1, dic)) is $(e.TypeNameType))#>
        | Expr.As as e => $<#($(GenerateScenarioFilterImpl(e.Expr1, dic)) as $(e.Type))#>
        | DotNet.IntegerLiteral
        | DotNet.RealLiteral
        | DotNet.Expr.BooleanLiteral
        | DotNet.Expr.Char
        | DotNet.Expr.String => expr.ToString().Trim()
        | Expr.Invocation as e =>
        def args = e.Arguments.Map(GenerateScenarioFilterImpl(_, dic));
        $<#$(GenerateScenarioFilterImpl(e.Left, dic))(..$args)#>;

        | Expr.IndexerAccess as e =>
        def args = e.Arguments.Map(GenerateScenarioFilterImpl(_, dic));
        $<#$(GenerateScenarioFilterImpl(e.Left, dic))[..$args]#>;
        
        | Expr.Parenthesized   as e => GenerateScenarioFilterImpl(e.Expression, dic)
        | Expr.PostDecrement (Expr1=e) with op = "++"
        | Expr.PostIncrement (Expr1=e) with op = "--"
          => $<#$(GenerateScenarioFilterImpl(e, dic))$op#>

        | Expr.PreIncrement    (Expr1=e) with op = "++"
        | Expr.PreDecrement    (Expr1=e) with op = "--"
        | Expr.BitwiseNegation (Expr1=e) with op = "~"
        | Expr.LogicalNegation (Expr1=e) with op = "!"
        | Expr.Negation        (Expr1=e) with op = "-"
          => $<#$op$(GenerateScenarioFilterImpl(e, dic))#>
        
        | Expr.TypeOf as e => $<#typeof($(e.Type))#>
        | Expr.GreaterThanOrEqual(Expr1=e1, Expr2=e2)  with op = ">="
        | Expr.LessThanOrEqual   (Expr1=e1, Expr2=e2)  with op = "<=" 
        | Expr.Less              (Expr1=e1, Expr2=e2)  with op =  "<"
        | Expr.Greater           (Expr1=e1, Expr2=e2)  with op =  ">"
        | Expr.ConditionalAnd    (Expr1=e1, Expr2=e2)  with op = "&&"
        | Expr.ConditionalOr     (Expr1=e1, Expr2=e2)  with op = "||"
        | Expr.Equal             (Expr1=e1, Expr2=e2)  with op = "=="
        | Expr.NotEqual          (Expr1=e1, Expr2=e2)  with op = "!="
        | Expr.NullCoalescing    (Expr1=e1, Expr2=e2)  with op = "??"
        | Expr.LogicalOr         (Expr1=e1, Expr2=e2)  with op = "|"
        | Expr.LogicalAnd        (Expr1=e1, Expr2=e2)  with op = "&"
        | Expr.LogicalXor        (Expr1=e1, Expr2=e2)  with op = "~"
        | Expr.ShiftLeft         (Expr1=e1, Expr2=e2)  with op = "<<"
        | Expr.ShiftRight        (Expr1=e1, Expr2=e2)  with op = ">>"
        | Expr.Sum               (Expr1=e1, Expr2=e2)  with op = "+"
        | Expr.Sub               (Expr1=e1, Expr2=e2)  with op = "-"
        | Expr.Modulus           (Expr1=e1, Expr2=e2)  with op = "%"
        | Expr.Multiply          (Expr1=e1, Expr2=e2)  with op = "*"
        | Expr.Divide            (Expr1=e1, Expr2=e2)  with op = "/"
          => $<#($(GenerateScenarioFilterImpl(e1, dic)) $op $(GenerateScenarioFilterImpl(e2, dic)))#>
        | Expr.Cast           as e => $<#(($(e.TypeName))$(GenerateScenarioFilterImpl(e.Expression, dic)))#>

        | Expr.Conditional as e =>
        def type = e.Type.FullName;
        $<#($(GenerateScenarioFilterImpl(e.Condition, dic)) ? (($type)$(GenerateScenarioFilterImpl(e.Expr1, dic))) : (($type)$(GenerateScenarioFilterImpl(e.Expr2, dic))))#>

        | Expr.Argument as a => GenerateScenarioFilterImpl(a.Expr, dic)
        | Expr.MemberAccess1 as e =>
            def member = e.Ref.Symbol;
            if (e.Expr1.Type is Tdl.SuiteTypeSymbol && member is Tdl.FieldSymbol)
              $<#(($(e.Type))globals["$(member.Name)"])#>
            else
              GenerateScenarioFilterImpl(e.Expr1, dic) + "." + member.Name

        | Expr.SimpleName as e => GenerateBySymbol(e.Ref.Symbol, dic)
        | _ => GenerateScenarioFilter()
      }
    }

    private GenerateSuiteGroup(suiteSymbol : Suite.ListSymbol) : string * SuiteGroup
    {
      (suiteSymbol.Name, SuiteGroup() <- { Suites = suiteSymbol.AllSuites.Select(_.Name).ToList(); })
    }

    private GenerateSuiteGenerator(g : Suite.GeneratorSymbol, suites : List[string * TestSuite], suiteGroups : List[string * SuiteGroup]) : void
    {
      def nameBase = g.Name;
      def names = List();

      foreach (dic in SubstituteVariables(g.Froms, 0))
      {
        def toString(e : Tdl.Expr) : string
        {
          | String as s => s.Value
          | _ => e.ToString()
        }
        def name = $<#$nameBase-..$(dic.Values; "-"; toString)#>;
        names.Add(name);
        def platform   = TryResolveVar(dic, g.Platform) : PlatformSymbol;
        def product    = TryResolveVar(dic, g.Product)  : ProductSymbol;

        def parameters = CollectDefs(g.Defs, dic).ToDictionary();
        foreach (d when !parameters.ContainsKey(d.Name) in g.DefaultDefs)
          parameters.Add(d.Name, ParameterDefaultValue);
        
        def entityOpt = if (g.EntityOpt.HasValue) (TryResolveVar(dic, g.EntityOpt.Value)  : EntitySymbol).Name else null;
        def suite = TestSuite() <- 
        {
          Platforms     = array[platform.Name];
          Products      = array[product.Name];
          TestScenarios = g.Statements.OfType.[Tdl.SuiteStatement.CallScenario]().Select(s => s.Reference.Name).ToArray();
          Parameters    = parameters;
          TestEntity    = entityOpt;
        };

        suites.Add(name, suite);
      }

      suiteGroups.Add(nameBase, SuiteGroup() <- { Suites = names; });
    }

    private GenerateSuite(suiteSymbol : Suite.DefSymbol) : string * TestSuite
    {
      def parameters = CollectDefs(suiteSymbol.Defs).ToDictionary();
      foreach (d in suiteSymbol.DefaultDefs)
        parameters.Add(d.Name, ParameterDefaultValue);
      def entityOpt = suiteSymbol.EntityOpt;
      def suite = TestSuite() <- 
      {
        Platforms     = array[suiteSymbol.Platform.Name];
        Products      = array[suiteSymbol.Product.Name];
        TestScenarios = suiteSymbol.Statements.OfType.[Tdl.SuiteStatement.CallScenario]().Select(s => s.Reference.Name).ToArray();
        Parameters    = parameters;
        TestEntity    = if (entityOpt.HasValue) entityOpt.Value.Name else null;
      };

      (suiteSymbol.Name, suite)
    }
  } // module
} // namespace
