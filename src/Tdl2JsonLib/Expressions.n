using Tdl;
using DotNet;
using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using Nitra;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Tdl2Json
{
    module Expressions
    {
        public ToObject(this expression : Tdl.Expr) : object
        {
          def loop(expression : Tdl.Expr) : object
          {
            | Error             => "<error>";
            | False             => BooleanLiterals.False
            | True              => BooleanLiterals.True
            | Integer      as i => i.Value
            | Real         as r => r.Value
            | Reference(Symbol=TypedDeclarationSymbol(Type=ProductTypeSymbol) as s) => "Product:" + s.Name
            | Reference    as r => r.Symbol.Name
            | MemberAccess as m => loop(m.Expr) + "." + m.Symbol.Name
            | String       as s => s.Value
            | List         as xs => def elems = xs.Elems.Select(loop);  $<#[..$elems]#>
            | _ => assert(false);
          }
          
          match (expression)
          {
            | Reference
            | MemberAccess => "$(" + loop(expression) + ")"
            | _            => loop(expression)
          }
        }
        
        public ToDictionary[TKey, TValue](this seq : Seq[TKey * TValue]) : Dictionary[TKey, TValue]
        {
          def dictionary = Dictionary();
          foreach ((k, v) in seq)
            dictionary.Add(k, v);
          dictionary
        }
        
        public ToNullable[T](this value : ParsedValue[T]) : T?
          where T: struct
        {
          if (value.HasValue) Nullable(value.Value) else null
        }
    }
}
