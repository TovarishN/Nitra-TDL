using Tdl;
using DotNet;
using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using Nitra;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Tdl2Json
{
  module Expressions
  {
    private enum ObjectType
    {
      | Value
      | ExternalParameter
      | GlobalParameter
      | External
      | Product
    }

    public ToObject(this expression : Tdl.Expr,
                    values    : IReadOnlyDictionary[string, object]          = null,
                    variables : Dictionary[TypedDeclarationSymbol, Tdl.Expr] = null) : object
    {
      def convert(expression : Tdl.Expr) : object * ObjectType
      {
        | Error              => ("<error>",             ObjectType.Value)
        | False              => (BooleanLiterals.False, ObjectType.Value)
        | True               => (BooleanLiterals.True,  ObjectType.Value)
        | Integer      as i  => (i.Value,               ObjectType.Value)
        | Real         as r  => (r.Value,               ObjectType.Value)
        | String       as s  => (s.Value,               ObjectType.Value)
        | List         as xs =>
          def elems = xs.Elems.Select(e => ToObject(e, values, variables));
          ($<#[..$elems]#>, ObjectType.Value)

        | Reference(Symbol=VarSymbol      as s)                                       => convert(variables[s])
        | Reference(Symbol=FieldSymbol    as s) when s.Owner?.Owner is ExternalSymbol => (s.Name, ObjectType.ExternalParameter)
        | Reference(Symbol=ExternalSymbol as s)                                       => (s.Name, ObjectType.External)
        | Reference(Symbol=TypedDeclarationSymbol(Type=ProductTypeSymbol) as s)       => (s.Name, ObjectType.Product)
        | Reference(Symbol=s) =>
          mutable referenceValue;
          if (values != null && values.TryGetValue(s.Name, out referenceValue))
            (referenceValue, ObjectType.Value)
          else
            (s.Name, ObjectType.GlobalParameter)

        | MemberAccess as m =>
          match (convert(m.Expr))
          {
            | (value, ObjectType.Product)  => ("Product:" + value + "." + m.Symbol.Name, ObjectType.GlobalParameter)
            | (_,     ObjectType.External) => (m.Symbol.Name,                            ObjectType.ExternalParameter)
            | _                            => throw NotSupportedException($"Invalid member access expression '$m'.")
          }

        | x => throw NotSupportedException($"Invalid expression '$x'.")
      }

      match (convert(expression))
      {
        | (value, ObjectType.Value)             => value
        | (value, ObjectType.ExternalParameter) => "#(" + value + ")"
        | (value, ObjectType.GlobalParameter)   => "$(" + value + ")"
        | (value, ObjectType.Product)           => value
        | (_,     ObjectType.External)          => throw NotSupportedException("Reference to externals root symbol is not allowed.")
      }
    }

    public ToDictionary[TKey, TValue](this seq : Seq[TKey * TValue]) : Dictionary[TKey, TValue]
    {
      def dictionary = Dictionary();
      foreach ((k, v) in seq)
        dictionary.Add(k, v);
      dictionary
    }
    
    public ToNullable[T](this value : ParsedValue[T]) : T?
      where T: struct
    {
      if (value.HasValue) Nullable(value.Value) else null
    }
  }
}
