using DotNet;
using DotNet.AstUtils;

using Nitra;
using Nitra.Declarations;
using Nitra.ProjectSystem;
using Nitra.Runtime.GraphUtils;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Text;

namespace Tdl
{
  module TdlUtils
  {
    static RequiredProductTypeFields : list[string] = ["Name", "ReleaseName", "Version"];
    
    public NoLocation         : Location           = Location(SourceSnapshot.Default.File, NSpan(0));
    public NoFile             : ProjectSystem.File = SourceSnapshot.Default.File;
    public NoSpan             : NSpan              = NSpan(0);
    
    public BaseStableGuid : Guid = Guid.Parse("{AAAAAAAA-AAAA-AAAA-AAAA-AAAAAAAAAAAA}");
    
    public ToTdlContext(this context : DependentPropertyEvalContext) : TdlDependentPropertyEvalContext
    {
      context :> TdlDependentPropertyEvalContext;
    }

    public GetExternalSymbolTable(this context : DependentPropertyEvalContext) : TableScope
    {
      ToTdlContext(context).TdlProjectData.ExternalSymbolTable
    }

    public GetScenarioParameterScope(this context : DependentPropertyEvalContext) : Scope
    {
      ToTdlContext(context).TdlProjectData.ScenarioParameterScope
    }

    public GetRequiredScenarioParameters(this context : DependentPropertyEvalContext) : ImmutableArray[FormalParameterSymbol]
    {
      ToTdlContext(context).TdlProjectData.RequiredScenarioParameters
    }

    public GetMethodScopeFactory(this context : DependentPropertyEvalContext) : ScopeFactory
    {
      ToTdlContext(context).TdlProjectData.MethodScopeFactory
    }

    public PlatformMakeHint(symbolCache : ISymbolCache, symbol : Platform.SetSymbol) : string
    {
      def builder = StringBuilder();
      try
      {
        symbolCache?.CacheSymbol(symbol);
        _ = builder.Append("<keyword>").HintMlEscape(symbol.Kind).Append("</keyword> ")
          .SymbolToHintMlWithSubHint(symbol)
          .Append(" = ");

        if (symbol.IsPlatformsEvaluated)
          _ = builder.Join(symbol.Platforms, HintML.SymbolToHintMlWithSubHint(_, _))
        else
          _ = builder.Append(<# <b><font color="Red">The Platforms not evaluated</font></b>.#>);

        _ = builder.MakeLocations(symbol);
      }
      catch { e => _ = builder.HintMlException(e); }
      builder.ToString()
    }
    
    public DeploymentMakeHint(symbolCache : ISymbolCache, symbol : Deployment.ScriptSymbol) : string
    {
      def builder = StringBuilder();
      try
      {
        symbolCache?.CacheSymbol(symbol);
        _ = builder.Append("<keyword>").HintMlEscape(symbol.Kind).Append("</keyword> ")
          .SymbolToHintMlWithSubHint(symbol)
          .Append(" = ");

        def project = symbolCache :> Project;
        
        def (_, _, rootNs) = (project.Data :> IDotNetBackEnd * DependentPropertyEvalContext * NamespaceSymbol);
        
        def scenarios = rootNs.MemberTable
          .GetAllSymbols()
          .OfType.[Scenario.DefSymbol]()
          .Where(s => s.Deployment.Id == symbol.Id || s.Deployment.AllDeployments.Contains(symbol))
          .ToList();
        
        if (scenarios.Count == 0)
          _ = builder.Append(<#Deployment is not used in any scenario.#>);
        else
        {
          _ = builder.Join(scenarios.Take(10), HintML.SymbolToHintMlWithSubHint(_, _));
          when (scenarios.Count > 10)
            _ = builder.Append(<#Deployment is not used in any scenario.#>);
        }

        _ = builder.MakeLocations(symbol);
      }
      catch { e => _ = builder.HintMlException(e); }
      builder.ToString()
    }
    
    public MakeDeployments(deploymentRefs : ImmutableArray[Ref[DeploymentSymbol]]) : ImmutableArray[DeploymentSymbol]
    {
      def builder = ImmutableArray.CreateBuilder();
      foreach (r in deploymentRefs)
      {
        when (r.IsSymbolEvaluated)
          builder.Add(r.Symbol);
      }
      builder.ToImmutable()
    }

    public ResolveDeployments(deploymentRefs : ImmutableArray[Ref[DeclarationSymbol]]) : ImmutableArray[Ref[DeploymentSymbol]]
    {
      def builder = ImmutableArray.CreateBuilder(deploymentRefs.Length);
      foreach (r in deploymentRefs)
        builder.Add(r.Resolve());
      builder.MoveToImmutable()
    }
    
    public MakeAllProducts(it : ProductSymbol, products : ImmutableArray[ProductSymbol]) : ImmutableArray[ProductSymbol]
    {
      def builder = ImmutableArray.CreateBuilder();
      def visited = HashSet();
      _ = visited.Add(it.Id);
      
      def collect(products : ImmutableArray[ProductSymbol]) : void
      {
        foreach (product in products)
        {
          unless (visited.Add(product.Id))
            continue;

          match (product)
          {
            | p   is Product.DefSymbol => builder.Add(p);
            | set is Product.SetSymbol => collect(set.Products);
            | _ => ()
          }
        }
      }

      collect(products);
      
      builder.ToImmutable()
    }

    public MakeProducts(deploymentRefs : ImmutableArray[Ref[DeclarationSymbol]]) : ImmutableArray[ProductSymbol]
    {
      def builder = ImmutableArray.CreateBuilder();
      foreach (deploymentRef in deploymentRefs)
      {
        def r = deploymentRef.Resolve();
        when (r.IsSymbolEvaluated)
          builder.Add(r.Symbol);
      }
      builder.ToImmutable()
    }

    // TODO: Пороверить, что все UniqueId у всех обрабатываемых сценариев был уникальны.
    
    public MakeScenarios(scenariosRefs : ImmutableArray[Ref[DeclarationSymbol]]) : ImmutableArray[ScenarioSymbol]
    {
      def builder = ImmutableArray.CreateBuilder();
      foreach (scenariosRef in scenariosRefs)
      {
        def r = scenariosRef.Resolve();
        when (r.IsSymbolEvaluated)
          builder.Add(r.Symbol);
      }
      builder.ToImmutable()
    }

    public MakeAggregateParametersScope(deployments : Seq[DeploymentSymbol]) : ValueOption[Scope]
    {
      def visited = HashSet();
      mutable builder = UnionScopeBuilder();
      if (CollectDeployments(visited, ref builder, deployments))
        VSome(builder.ToScope())
      else
        VNone()
    }

    private CollectDeployments(visited : HashSet[int], builder : ref UnionScopeBuilder, deployments : Seq[DeploymentSymbol]) : bool
    {
      foreach (deployment in deployments)
      {
        unless (visited.Add(deployment.Id))
          continue;

        match (deployment)
        {
          | s is Deployment.ScriptSymbol   =>
            unless (s.IsParameterScopeEvaluated)
              return false;
            UnionScopeBuilder.Add(s.ParameterScope, ref builder);
            
          | s is Deployment.SelectSymbol   =>
            unless (s.IsParameterScopeEvaluated)
              return false;
            UnionScopeBuilder.Add(s.ParameterScope, ref builder);

            unless (CollectDeployments(visited, ref builder, s.Deployments))
              return false;
            
          | s is Deployment.SetSymbol      =>
            unless (CollectDeployments(visited, ref builder, s.Deployments))
              return false;

          | s is Deployment.CurryingSymbol =>
            unless (s.IsAggregateParametersScopeEvaluated)
              return false;
            UnionScopeBuilder.Add(s.AggregateParametersScope, ref builder);
          
          | _ is DeploymentRebootSymbol    => ()
            
          | null => assert(false, "The deployment can't be null.")
          | _    => assert(false, "Not supported deployment type: " + deployment.GetType().Name)
        }
      }
      true
    }

    public MakeAggregateParametersScope(scenarios : ImmutableArray[ScenarioSymbol]) : Scope
    {
      def visited = HashSet();
      mutable builder = UnionScopeBuilder();
      CollectScenarios(visited, ref builder, scenarios);
      builder.ToScope()
    }

    private CollectScenarios(visited : HashSet[int], builder : ref UnionScopeBuilder, scenarios : ImmutableArray[ScenarioSymbol]) : void
    {
      foreach (deployment in scenarios)
      {
        unless (visited.Add(deployment.Id))
          return;

        match (deployment)
        {
          | s is Scenario.DefSymbol when s.IsDeploymentEvaluated && s.Deployment.IsAggregateParametersScopeEvaluated =>
            UnionScopeBuilder.Add(s.Deployment.AggregateParametersScope, ref builder);
          | s is Scenario.SetSymbol when s.IsScenariosEvaluated  => CollectScenarios(visited, ref builder, s.Scenarios);
          | _ => ()
        }
      }
    }

    public MakeExpected(valueOpt : DeploymentOption.Success.IAstOption) : ParsedValue[int]
    {
      if (valueOpt.HasValue) valueOpt.Value.Value else ParsedValue(valueOpt.Span.StartPos)
    }
    
    public MakeForReboot(valueOpt : DeploymentOption.ForReboot.IAstOption) : ParsedValue[int]
    {
      if (valueOpt.HasValue) valueOpt.Value.Value else ParsedValue(valueOpt.Span.StartPos)
    }

    public ConvertStringLiteral(this valueOpt : DeploymentOption.Timeout.IAstOption) : ParsedValue[string]
    {
      if (valueOpt.HasValue) TdlUtils.ConvertStringLiteral(valueOpt.Value.Value) else ParsedValue(valueOpt.Span.StartPos)
    }

    public ConvertStringLiteral(this valueOpt : CSharp.StringLiteral.IAstOption) : ParsedValue[string]
    {
      if (valueOpt.HasValue) TdlUtils.ConvertStringLiteral(valueOpt.Value) else ParsedValue(valueOpt.Span.StartPos)
    }

    public ConvertStringLiteralOrNull(str : CSharp.StringLiteral) : string
    {
      def rsult = ConvertStringLiteral(str);
      if (rsult.HasValue)
        rsult.Value
      else
        null
    }
    
    [DebuggerStepThroughAttribute]
    private HexDigit(c : char) : int
    {
      | c when '0' <= c && c <= '9' => c : int - '0' : int
      | c when 'a' <= c && c <= 'f' => c : int - 'a' : int + 10
      | c when 'A' <= c && c <= 'F' => c : int - 'A' : int + 10
      | _ => assert3(false)
    }

    [DebuggerStepThroughAttribute]
    public HexToInt(location : Location, startPos : int, endPos : int) : int
    {
      assert2(startPos < endPos);

      def text = location.Source.OriginalText;
      mutable result = HexDigit(text[startPos]);

      for (mutable i = startPos + 1; i < endPos; i++)
        unchecked result = (result << 4) + HexDigit(text[i]);

      result
    }
    
    public ConvertStringLiteral(str : CSharp.StringLiteral) : ParsedValue[string]
    {
      def builder = Text.StringBuilder();
      foreach (part in str.Parts)
      {
        | Interpolation           => ()
        | InterpolationFormated   => ()
        | InterpolatedOpenEscape  => _ = builder.Append("{");
        | InterpolatedCloseEscape => _ = builder.Append("}");
        | Error                   => ()
        | SimpleEscape       as x =>
          def text = x.Source.Text;
          _ = builder.Append(Nitra.Internal.DotUtils.EscapeSequence(text[x.Span.StartPos + 1]));
          
        | UnicodeEscape      as x 
        | HexadecimalEscape  as x =>
          def span = x.Span;
          def value = HexToInt(part.Location, span.StartPos + 3, span.EndPos);
          try
            _ = builder.Append(value :> char);
          catch { _ is OverflowException => return ParsedValue(str.Span.StartPos); }
        
        | RegulaChars             => _ = builder.Append(part.Location.GetText());
        | VerbatimEscape          => _ = builder.Append('"');
        | _                       => ()
      }

      ParsedValue(str.Span, builder.ToString())
    }

    private ConvertDefExpr(expr : DefExpr) : Expr
    {
      match (expr)
      {
        | x is DefExpr.String                    => Expr.String(ConvertStringLiteral(x.Value).Value)
        | _ is DefExpr.True                      => Expr.True()
        | _ is DefExpr.False                     => Expr.False()
        | x is DefExpr.RealLiteral               => Expr.Real(double.Parse(x.Location.GetText()))
        | x is DefExpr.DecimalIntegerLiteral     => Expr.Integer(int.Parse(x.Location.GetText()))
        | x is DefExpr.HexadecimalIntegerLiteral => Expr.Integer(int.Parse(x.Location.GetText().Substring(2), NumberStyles.HexNumber))
        | x is DefExpr.MemberAccess              => Expr.MemberAccess(ConvertDefExpr(x.Expr), x.Member.Location.GetText())
        | x is DefExpr.Reference  
          when x.IsTypedRefEvaluated             => Expr.Reference(x.Location.GetText(), x.Type)
        | x                                      => Expr.Error(x.Location)
      }
    }

    public MakeDefinitions(definitions : Definition.IAstList, _dependence : ImmutableArray[Ref[TypedDeclarationSymbol]]) : ImmutableArray[Def]
    {
      def builder = ImmutableArray.CreateBuilder(definitions.Count);
      foreach (definition when definition.IsSymbolRefEvaluated && definition.SymbolRef.IsSymbolEvaluated in definitions)
        builder.Add(Def(definition.SymbolRef.Symbol, ConvertDefExpr(definition.Expr)));
      builder.TryMoveToImmutable()
    }

    public MakeDefinitions(definitions : Definition.IAstList, context : DependentPropertyEvalContext, _dependence : ImmutableArray[Ref[TypedDeclarationSymbol]]) : ImmutableArray[Def]
    {
      def builder = ImmutableArray.CreateBuilder(definitions.Count);
      foreach (definition when definition.IsSymbolRefEvaluated && definition.SymbolRef.IsSymbolEvaluated in definitions)
      {
        def sym = definition.SymbolRef.Symbol;
        when (sym is FormalParameterSymbol as p when p.IsDeclaredInEvaluated)
        {
          when (p.DeclaredIn is Deployment.SelectSymbol as sel)
          {
            mutable found;
            def index = sel.Parameters.IndexOf(p);
            assert2(index >= 0);
            def value = ConvertDefExpr(definition.Expr);
            when (value is Tdl.Expr.String as str)
            {
              foreach (case when index < case.Length in sel.Cases)
              {
                def val = case[index];
                when (string.Equals(val, str.Value, StringComparison.Ordinal))
                {
                  found = true;
                  break;
                }
              }
              unless (found)
              {
                def msgs = context.GetFileData(definitions.Location.Source.File.Id).GetCompilerMessage();
                using (root = msgs.ReportRootMessage(CompilerMessageType.Error, definition.Expr.Location, $"The '$(sel.Name)' select statement does not contain a '$(str.Value)' value.", 0))
                  root.ReportMessage(CompilerMessageType.Hint, sel.FirstDeclarationOrDefault.Name.Location, "The related select statement.", 0);
              }
            }
          }
        }
        builder.Add(Def(sym, ConvertDefExpr(definition.Expr)));
      }
      builder.TryMoveToImmutable()
    }

    public MakeDefinitions(definitions : Definition.IAstList) : ImmutableArray[Def2]
    {
      def builder = ImmutableArray.CreateBuilder(definitions.Count);
      foreach (definition in definitions)
        builder.Add(Def2(definition.Reference.Text, ConvertDefExpr(definition.Expr)));
      builder.TryMoveToImmutable()
    }
    
    public Resolve(platformRefs : ImmutableArray[Ref[DeclarationSymbol]]) : ImmutableArray[Ref[PlatformSymbol]]
    {
      def builder = ImmutableArray.CreateBuilder(platformRefs.Length);
      foreach (platformRef in platformRefs)
        builder.Add(platformRef.Resolve());
      builder.TryMoveToImmutable()
    }

    public ToSymbol(it : PlatformSymbol, platforms : ImmutableArray[Ref[PlatformSymbol]]) : ImmutableArray[PlatformSymbol]
    {
      def builder = ImmutableArray.CreateBuilder(platforms.Length);
      def visited = HashSet();
      _ = visited.Add(it);
      def loccectAllPlatforms(platforms : ImmutableArray[Ref[PlatformSymbol]])
      {
        foreach (platformRef when platformRef.IsSymbolEvaluated in platforms)
        {
          unless (visited.Add(platformRef.Symbol))
            continue;
          match (platformRef.Symbol)
          {
            | s is Platform.DefSymbol => builder.Add(s);
            | s is Platform.SetSymbol => loccectAllPlatforms(s.PlatformsRefs);
            | _ => assert(false)
          }
        }
      }

      loccectAllPlatforms(platforms);

      builder.TryMoveToImmutable()
    }

    public MakeExcludedParams(baseDeploymentRefs : ImmutableArray[Ref[TypedDeclarationSymbol]]) : ImmutableArray[FormalParameterSymbol]
    {
      def builder = ImmutableArray.CreateBuilder(baseDeploymentRefs.Length);
      foreach (r in baseDeploymentRefs)
      {
        def res = r.Resolve.[FormalParameterSymbol]();
        when (res.IsSymbolEvaluated)
          builder.Add(res.Symbol);
      }
      builder.TryMoveToImmutable()
    }

    public MakeCurryingScope(scope : Scope, excludedParams : ImmutableArray[FormalParameterSymbol]) : Scope
    {
      def predicate(symbol : DeclarationSymbol) : bool
      {
        def id = symbol.Id;
        foreach (excludedParam in excludedParams)
          when (excludedParam.Id == id)
            return false;

        true
      }
      FilteringScope(scope, predicate)
    }
    
    public MakeParameterScope(scope : Scope) : Scope
    {
      FilteringScope(scope, HashSet(ParameterComparer()).Add)
    }
    
    public IsMissingRequiredOptions(context : DependentPropertyEvalContext, options : ImmutableArray[Ref[TypedDeclarationSymbol]]) : bool
    {
      GetMissingRequiredOptionNames(context, options).Any()
    }

    GetMissingRequiredOptionNames(context : DependentPropertyEvalContext, options : ImmutableArray[Ref[TypedDeclarationSymbol]]) : Seq[string]
    {
      def optionSet = HashSet();
      foreach (option when option.IsSymbolEvaluated in options)
        _ = optionSet.Add(option.Symbol.Id);

      foreach (required in context.GetRequiredScenarioParameters())
        unless (optionSet.Contains(required.Id))
          yield required.Name;
    }
    
    public GetMissingRequiredOptionMessage(context : DependentPropertyEvalContext, options : ImmutableArray[Ref[TypedDeclarationSymbol]]) : string
    {
      string.Join(", ", GetMissingRequiredOptionNames(context, options))
    }

    public TryMoveToImmutable[T](this builder : ImmutableArray[T].Builder) : ImmutableArray[T]
    {
      if (builder.Capacity == builder.Count)
        builder.MoveToImmutable()
      else
        builder.ToImmutable()
    }

    public MakeDeploymentScope(scope : Scope) : Scope
    {
      def filter(symbol : DeclarationSymbol) : bool
      {
        | DeploymentSymbol => true
        | _                => false
      }

      def filteringScope = FilteringScope(scope, filter);
      filteringScope
    }
    
    public HasUndefinedFieldsInProduct(type : ProductTypeSymbol, defs : ImmutableArray[Def]) : bool
    {
      CollectUndefinedFieldsInProduct(type, defs).Any()
    }
    
    public ReportProduct(type : ProductTypeSymbol, defs : ImmutableArray[Def]) : string
    {
      def undefinedFields = CollectUndefinedFieldsInProduct(type, defs).Select(x => x.Name).OrderBy(x => x);
      "The product does not have fields declared in the product type: " + string.Join(", ", undefinedFields) + "."
    }

    CollectUndefinedFieldsInProduct(type : ProductTypeSymbol, defs : ImmutableArray[Def]) : Seq[DeclarationSymbol]
    {
      def fieldSet = type.MemberTable.GetAllSymbols();
      def defSet   = defs.Select(d => d.Symbol);
      fieldSet.Except(defSet)
    }
    
    public ResolveSuiteTypeSymbol(this context : DependentPropertyEvalContext, typeRef : Ref[DeclarationSymbol]) : SuiteTypeSymbol
    {
      def makeDefaulteSuiteTypeSymbol()
      {
        def symbol = SuiteTypeSymbol();
        symbol.EvalProperties(context);
        symbol
      }

      if (typeRef == null)
        makeDefaulteSuiteTypeSymbol()
      else
      {
        def result = typeRef.Resolve();
        if (result.IsUnresolved)
          makeDefaulteSuiteTypeSymbol()
        else
          result.Symbol
      }
    }
    
    public IsMissingRequiredProductTypeFields(fields : ImmutableArray[Tdl.FieldSymbol]) : bool
    {
      def set = HashSet(RequiredProductTypeFields);
      foreach (field in fields)
        _ = set.Remove(field.Name);
      set.Count > 0
    }
    
    public GetMissingRequiredProductTypeFieldsMessage(fields : ImmutableArray[Tdl.FieldSymbol]) : string
    {
      def set = HashSet(RequiredProductTypeFields);
      foreach (field in fields)
        _ = set.Remove(field.Name);
      
      $"Missing required fields: ..$set"
    }
    
    public ReportDuplicateBarrier(this ast : IAst, context : DependentPropertyEvalContext, actions : ImmutableArray[ScenarioAction]) : void
    {
      def set = HashSet();
      foreach (b is ScenarioAction.Barrier when !set.Add(b.barrier.Id) in actions)
      {
        def loc = Location(ast.Location.Source, b.Location.StartPos, b.Location.EndPos);
        def msgs = context.GetFileData(ast.Location.Source.File.Id).GetCompilerMessage();
        msgs.ReportMessage(CompilerMessageType.Error, loc, "Multiple usage of barrier " + b.barrier.InitialName, 0);
      }
    }
    
    [Record]
    struct Edge
    {
      public From : ScenarioAction.Barrier;
      public To   : ScenarioAction.Barrier;
    }

    [Record]
    class Node[TSymbol] : GraphNodeWithConnections[Node[TSymbol]]
      where TSymbol : DeclarationSymbol
    {
      public Symbol : TSymbol;
    }
    
    public CheckMultiMachineScenario(this ast : IAst, context : DependentPropertyEvalContext, scenarios : ImmutableArray[ScenarioSymbol], _depend : object) : void
    {
      def edges = List();
      def nodesMap = Dictionary();
      def loop(scenario : ScenarioSymbol) : void
      {
        | Scenario.DefSymbol as d =>
          unless (d.IsActionsEvaluated)
            return;
            
          mutable prev;
          foreach (action is ScenarioAction.Barrier in d.Actions)
          {
            mutable node;
            unless (nodesMap.TryGetValue(action.barrier, out node))
            {
              node = Node(action.barrier);
              nodesMap.Add(action.barrier, node);
            }
            
            when (prev != null)
            {
              nodesMap[prev.barrier].AddConnection(node);
              edges.Add(Edge(prev, action));
            }
            
            prev = action;
          }
        
        | Scenario.SetSymbol as s =>
          unless (s.IsScenariosEvaluated)
            return;
          foreach (scenario in s.Scenarios)
            loop(scenario);
        | Scenario.GeneratorSymbol => ()
        | _ => assert(false)
      }
      foreach (scenario in scenarios)
        loop(scenario);
        
      def groups = GraphAlgorithms.FindStronglyConnectedComponents(nodesMap.Values);
      
      foreach (group in groups)
        when (group.IsNonTrivial())
        {
          def symbols = HashSet();
          foreach (node in group.Nodes)
            _ = symbols.Add(node.Symbol);
            
          def barrierUsages = HashSet();
          foreach (edge in edges)
          {
            when (symbols.Contains(edge.From.barrier) && symbols.Contains(edge.To.barrier))
            {
              _ = barrierUsages.Add(edge.From);
              _ = barrierUsages.Add(edge.To);
            }
          }
          
          def msgs               = context.GetFileData(ast.Location.Source.File.Id).GetCompilerMessage();
          def deadLockedBarriers = group.Nodes.ToArray().Map(n => AsName(n.Symbol.Name));
          foreach (usage in barrierUsages.OrderBy(u => u.Location.Source.File).ThenBy(u => u.Location.StartPos))
            msgs.ReportMessage(CompilerMessageType.Error, usage.Location, $"Barriers deadlock detected: ..$deadLockedBarriers", 0);
        }
    }

    public GetSetScenarios(scenarioSet : Scenario.SetSymbol) : List[Scenario.DefSymbol]
    {
      GetSetScenarios(scenarioSet, null)
    }
    
    public GetSetScenarios(scenarioSet : Scenario.SetSymbol, duplicates : HashSet[Scenario.SetSymbol * Scenario.DefSymbol]) : List[Scenario.DefSymbol]
    {
      def result  = List();
      def visited = HashSet();
      def loop(set : Scenario.SetSymbol) : void
      {
        unless (visited.Add(set))
          return;
        unless (set.IsScenariosEvaluated)
          return;
        foreach (scenario in set.Scenarios)
        {
          | Scenario.SetSymbol as subSet                => loop(subSet)
          | Scenario.DefSymbol as d when visited.Add(d) => result.Add(d);
          | Scenario.DefSymbol as d                     => when (duplicates != null) _ = duplicates.Add((set, d))
          | Scenario.GeneratorSymbol                    => ()
          | _ => assert(false)
        }
      }
      loop(scenarioSet);
      result
    }
    
    public CheckUniquenessOfScenarios(this _ast : IAst, context : DependentPropertyEvalContext, set : Scenario.SetSymbol, _depend : object) : void
    {
      def duplicates = HashSet();
      _ = GetSetScenarios(set, duplicates);
      when (duplicates.Count > 0)
      {
        def group = duplicates.GroupBy((set, _) => set);
        foreach (x in group)
        {
          foreach ((_, d) in x)
          {
            def decl = x.Key.FirstDeclarationOrDefault :> Scenario.Set;
            foreach (scenarioDecl when scenarioDecl.IsRefEvaluated && scenarioDecl.Ref.IsSymbolEvaluated in decl.Scenarios)
            {
              when (scenarioDecl.Ref.Symbol.Id == d.Id)
              {
                scenarioDecl.Error(context, "Duplicate scenario in group.");
              }
            }
          }
        }
      }
    }
    
    public CheckExpected(this ast : IAst, context : DependentPropertyEvalContext, type1 : TypeSymbol, type2 : TypeSymbol) : void
    {
      if (TdlTypeUnifier.Instance.TryProvide(type1, type2))
        _ = TdlTypeUnifier.Instance.Provide(type1, type2);
      else
        ast.Error(context, $"Expected '$(TypeToString(type1))' but got '$(TypeToString(type2))'.", 0);
    }

    public CheckExpectedForTuple(this ast : IAst, context : DependentPropertyEvalContext, items : QualifiedReference.IAstList, expectedType : TypeSymbol, type : TypeSymbol) : void
    {
      match (expectedType, type)
      {
        | _ when (items.Count < 2) => ast.Error(context, "A tuple must have more than one elements.", 0);
        | (expectedTuple is TdlType.TupleSymbol, tuple2 is TdlType.TupleSymbol) =>
          def expectedArgs = expectedTuple.Args;
          def args = tuple2.Args;
          
          when (expectedArgs.Length != items.Count || expectedArgs.Length != args.Length)
          {
            def got = if (expectedArgs.Length == items.Count) args.Length else items.Count;
            items.Error(context, $"Expected $(expectedArgs.Length) but got $got tuple elemens.", 0);
            return;
          }
            
          for (mutable i = 0; i < expectedArgs.Length; i++)
          {
            def t1   = expectedArgs[i];
            def t2   = args[i];
            def item = items[i];
            if (TdlTypeUnifier.Instance.TryUnify(t1, t2))
              _ = TdlTypeUnifier.Instance.Unify(t1, t2);
            else
              item.Error(context, $"Expected '$(TypeToString(expectedType))' but got '$(TypeToString(type))'.", 0);
          }
          
        | _ when TdlTypeUnifier.Instance.TryUnify(expectedType, type) => _ = TdlTypeUnifier.Instance.Unify(expectedType, type);
        | _ => ast.Error(context, $"Expected $(TypeToString(expectedType)) but got $(TypeToString(type)).", 0);
      }
    }
    
    public MakeTupleType(this context : DependentPropertyEvalContext, items : ImmutableArray[Ref[DeclarationSymbol]]) : TypeSymbol
    {
      def builder = ImmutableArray.CreateBuilder(items.Length);
      foreach (item in items)
      {
        def t =
          if (item.IsAmbiguous || item.IsUnresolved)
            context.CreateFreeTypeVar()
          else
          {
            def typed = item.Resolve() : Ref[TypedSymbol];
            if (typed.IsSymbolEvaluated)
              typed.Symbol.Type
            else
              context.CreateFreeTypeVar()
          };
        builder.Add(t);
      }
      
      def tuple = TdlType.TupleSymbol();
      tuple.Args = builder.MoveToImmutable();
      tuple.EvalProperties(context);
      tuple
    }
    
    TypeToString(type : TypeSymbol) : string
    {
      | f is FunctionTypeSymbol when f.IsParametersEvaluated && f.IsReturnEvaluated && f.Parameters.Length == 0 
                                  && f.Return.Name.Equals("void", StringComparison.OrdinalIgnoreCase)           => "Test method"
      | _ => type.ToString()
    }

    public MakeTuple(this context : DependentPropertyEvalContext, items : ImmutableArray[TypeSymbol]) : TypeSymbol
    {
      when (items.Length == 1)
        return items[0];
        
      def tuple = TdlType.TupleSymbol();
      tuple.Args = items;
      tuple.EvalProperties(context);
      tuple
    }
    
    public MakeFroms(froms : From.IAstList) : ValueOption[ImmutableArray[Code.From]]
    {
      def builder = ImmutableArray.CreateBuilder(froms.Count);
      foreach (from in froms)
      {
        when (!from.Vars.IsSymbolEvaluated || !from.List.IsSymbolsEvaluated)
          return VNone();
          
        def result = Code.From(from.Vars.Symbol, from.List.Symbols);
        builder.Add(result);
      }
      
      VSome(builder.MoveToImmutable())
    }

    public MakeTuple(this _context : DependentPropertyEvalContext, items : ImmutableArray[Ref[DeclarationSymbol]]) : ImmutableArray[DeclarationSymbol]
    {
       items.Select(x => if (x.IsSymbolEvaluated) x.Symbol else null).ToImmutableArray();
    }

    public CheckOptionForDuplicates(this _ast : IAst, context : DependentPropertyEvalContext, options : ImmutableArray[Ref[TypedDeclarationSymbol]]) : void
    {
      def duplicateSet = HashSet();
      foreach (option when option.IsSymbolEvaluated in options)
      {
        def id = option.Symbol.Id;
        unless (duplicateSet.Add(id))
        {
          option.Location.Error(context, "Duplicate option.");
        }
      }
    }
    
    public Error(this location : Location, context : DependentPropertyEvalContext, message : string) : void
    {
        def msgs = context.GetFileData(location.Source.File.Id).GetCompilerMessage();
        msgs.ReportMessage(CompilerMessageType.Error, location, message, 0);
    }

    public MakeSelectAggregateParametersScope(scope : TableScope, deployments : ImmutableArray[DeploymentSymbol]) : ValueOption[Scope]
    {
      def visited = HashSet();
      mutable builder = UnionScopeBuilder();
      if (CollectDeployments(visited, ref builder, deployments))
        VSome(builder.ToScope().HideWith(scope))
      else
        VNone()
    }

    public ChechSelectDeployment(this ast : IAst, context : DependentPropertyEvalContext, cases : Case.IAstList) : void
    {
      def msgs = context.GetFileData(ast.Location.Source.File.Id).GetCompilerMessage();
      
      mutable valuesCount = -1;
      foreach (case in cases)
      {
        if (valuesCount < 0)
          valuesCount = case.Values.Count;
        else when (valuesCount != case.Values.Count)
        {
          msgs.ReportMessage(CompilerMessageType.Error, case.Values.Location, "The case must has $valuesCount values.", 0);
          break;
        }
      }

      foreach (case in cases with k)
      foreach (value when value.Values == "" in case.Values)
        msgs.ReportMessage(CompilerMessageType.Error, value.Location, "The value can't be empty.", 0);
      
      def set = HashSet();
      foreach (case in cases with k)
      {
        def values = case.Values.Map(v => v.Values);
        unless (set.Add(values))
          msgs.ReportMessage(CompilerMessageType.Error, case.Values.Location, "Duplicate entry.", 0);
      }
    }
    
    public MakeDefaultDefs(this ast : IAst, context : DependentPropertyEvalContext, defs : ImmutableArray[Def], definitionScope : Scope, product : ProductSymbol) : ImmutableArray[FormalParameterSymbol]
    {
      def productParameters = product.ProductType.MemberTable.GetAllSymbols();
      def filteringScope    = definitionScope :> FilteringScope;
      def selectParams      = HashSet(filteringScope.Scope.GetAllSymbols()
                                                    .OfType.[FormalParameterSymbol]()
                                                    .Where(p => p.DeclaredIn is Deployment.SelectSymbol));
                                         
      when (selectParams.Count == 0)
        return ImmutableArray.Empty;
      
      def selectDeployments = HashSet(selectParams.Select(p => p.DeclaredIn :> Deployment.SelectSymbol));
      def paramMap          = Dictionary(ParameterComparer.Instance);
      
      // We fill the values explicitly specified.
      foreach (d in defs)
        when (d.Expr is Tdl.Expr.String as str)
          paramMap[d.Symbol] = str.Value;

      def getAllProducts(product : ProductSymbol) : Seq[Product.DefSymbol]
      {
        | Product.DefSymbol as ds => [ds]
        | Product.SetSymbol as ss => ss.AllProducts.OfType.[Product.DefSymbol]()
        | _ => assert(false);
      }

      foreach (ds in getAllProducts(product))
        foreach (d in ds.Defs)
          when (d.Expr is Tdl.Expr.String as str)
            paramMap[d.Symbol] = str.Value;

      foreach (s in selectDeployments)
      {
        def values = array(s.Parameters.Length);
        foreach (p in s.Parameters with k)
        {
          mutable value;
          when (paramMap.TryGetValue(p, out value))
            values[k] = value;
        }
        
        mutable isEntryPresent;
        foreach (entry in s.Cases)
        {
          when (entry.Length != values.Length)
            return ImmutableArray.Empty; // An error message has already been reported.

          mutable isEntryMatch = true;
          for (mutable i = 0; i < values.Length; i++)
          {
            isEntryMatch &= entry[i] == values[i];
            unless (isEntryMatch)
              break;
          }
          isEntryPresent |= isEntryMatch;
        }
        unless (isEntryPresent)
        {
          def entryStr = values.Select(v => if (v == null) "_" else <#"#> + v + '"');
          def msgs     = context.GetFileData(ast.Location.Source.File.Id).GetCompilerMessage();
          using (root = msgs.ReportRootMessage(CompilerMessageType.Error, ast.Location, $"The $(s.Name) select deployment has no ..$entryStr entry.", 0))
            root.ReportMessage(CompilerMessageType.Hint, s.FirstDeclarationOrDefault.Name.Location, "The related select deployment.", 0);
          return ImmutableArray.Empty;
        }
      }
      
      def distinctSelectParams = HashSet(selectParams, ParameterComparer.Instance);
      
      def builder = ImmutableArray.CreateBuilder(distinctSelectParams.Count);
      foreach (p when !paramMap.ContainsKey(p) in distinctSelectParams)
        builder.Add(p);
      _ = productParameters;
      builder.ToImmutable()
    }

    public AsName(text : string) : string
    {
      foreach (ch when char.IsWhiteSpace(ch) in text)
        return "\"" + text + '"';
      
      text
    }

    public CheckForRecursionProduct(this ast : IAst, context : DependentPropertyEvalContext, symbol : ProductSymbol, _depend : object) : void
    {
      def getDescendants(sym : ProductSymbol) : Seq[ProductSymbol]
      {
          | _ is Product.DefSymbol   => []
          | s is Product.SetSymbol      => if (s.IsProductsEvaluated) s.Products else []
          | s => assert(false, "Unsupported symbol type: " + s.GetType().FullName)
      }
      _ = CheckForRecursion(ast, context, symbol, getDescendants, _depend)
    }

    public CheckForRecursionScenario(this ast : IAst, context : DependentPropertyEvalContext, symbol : ScenarioSymbol, _depend : object) : void
    {
      def getDescendants(sym : ScenarioSymbol) : Seq[ScenarioSymbol]
      {
          | _ is Scenario.DefSymbol   => []
          | s is Scenario.SetSymbol      => if (s.IsScenariosEvaluated) s.Scenarios else []
          | _ is Scenario.GeneratorSymbol => [] // 
          | s => assert(false, "Unsupported symbol type: " + s.GetType().FullName)
      }
      _ = CheckForRecursion(ast, context, symbol, getDescendants, _depend)
    }
    
    public CheckForRecursionDeployment(this ast : IAst, context : DependentPropertyEvalContext, symbol : DeploymentSymbol, _depend : object) : ImmutableArray[DeploymentSymbol]
    {
      def getDescendants(sym : DeploymentSymbol) : Seq[DeploymentSymbol]
      {
          | _ is Deployment.ScriptSymbol   => []
          | s is Deployment.SetSymbol      => if (s.IsDeploymentsEvaluated)    s.Deployments      else []
          | s is Deployment.SelectSymbol   => if (s.IsDeploymentsEvaluated)    s.Deployments      else []
          | s is Deployment.CurryingSymbol => if (s.IsBaseDeploymentEvaluated) [s.BaseDeployment] else []
          | _ is DeploymentRebootSymbol    => []
          | s => assert(false, "Unsupported symbol type: " + s.GetType().FullName)
      }
      CheckForRecursion(ast, context, symbol, getDescendants, _depend)
    }
    
    public CheckForRecursion[TSymbol](ast : IAst, context : DependentPropertyEvalContext, symbol : TSymbol, getDescendants : TSymbol -> Seq[TSymbol], _depend : object) : ImmutableArray[TSymbol]
      where TSymbol: DeclarationSymbol
    {
      def nodesMap = Dictionary();
      def loop(parentNode : Node[TSymbol], sym : TSymbol) : void
      {
        def nodesMap = nodesMap;
        mutable node;
        unless (nodesMap.TryGetValue(sym, out node))
        {
          node = Node(sym);
          nodesMap.Add(sym, node);

          def descendants = getDescendants(sym).ToArray();
          foreach (subSym in descendants)
            loop(node, subSym);
        }
        
        when (parentNode != null)
          node.AddConnection(parentNode);
      }

      loop(null, symbol);
        
      def nodesMap = nodesMap;
      def groups = GraphAlgorithms.FindStronglyConnectedComponents(nodesMap.Values);
      
      foreach (group when group.IsNonTrivial() in groups)
      {
        def names = group.Nodes.ToArray().Map(n => AsName(n.Symbol.Name));
        def msg   = if (group.Nodes.Count == 1) $"$(names[0]) is cycled." else $"Detected a cycle between: ..$names.";
        def msgs  = context.GetFileData(ast.Location.Source.File.Id).GetCompilerMessage();
        foreach (node in group.Nodes)
        {
          def sym  = node.Symbol;
          def decl = sym.FirstDeclarationOrDefault;
          def loc  = decl.Name.Location;
          msgs.ReportMessage(CompilerMessageType.Error, loc, msg, 0);
        }
      }
      
      nodesMap.Keys.ToImmutableArray()
    }
    
    public SetUsed[T](this _ast : IAst, items : Seq[T], isUsed : bool) : void
      where T: UsedDeclarationSymbol
    {
      foreach (item when !item.IsIsUsedEvaluated in items)
        item.IsUsed = isUsed;
    }

    public SetUsed(this _ast : IAst, statements : Seq[SuiteStatement]) : void
    {
      foreach (statement in statements)
      {
        | CallScenario as s => unless (s.Reference.IsIsUsedEvaluated) s.Reference.IsUsed = true;
      }
    }

    public MakeAggregateParametersScope(deployment : TypedSymbol, froms : ImmutableArray[Code.From]) : ValueOption[Scope]
    {
      def deployments = List();
      foreach (from in froms)
      foreach (var when var.Id == deployment.Id in from.Vars with i)
      {
        foreach (elem in from.Elems)
        {
          when (elem[i] is DeploymentSymbol as d)
            deployments.Add(d);
        }
        break;
      }
      MakeAggregateParametersScope(deployments)
    }
    
    public ToInt(this maxRebootsCountOpt : OptionParseTree[GrammarParseTree.MaxRebootsCount]) : ParsedValue[int]
    {
      unless (maxRebootsCountOpt.HasValue)
        return ParsedValue(maxRebootsCountOpt.Span.StartPos);
        
      def lit = maxRebootsCountOpt.Value.Value;
      
      when (lit.IsMissing || lit.IsAmbiguous)
        return ParsedValue(lit.Span.StartPos);
      
      ParsedValue(lit.Span, int.Parse(lit.GetText()))
    }
    
    public IncrementGuid(guid : Guid, value : uint) : Guid
    {
      def bytes1   = guid.ToByteArray();
      def version  = BitConverter.ToUInt32(bytes1, 0) + value;
      def bytes2   = BitConverter.GetBytes(version);
      bytes1[0] = bytes2[0];
      bytes1[1] = bytes2[1];
      bytes1[2] = bytes2[2];
      bytes1[3] = bytes2[3];
      Guid(bytes1)
    }
    
    public NewGuid(this context : DependentPropertyEvalContext) : Guid
    {
      def data = context.ToTdlContext().TdlProjectData;
      if (data.IsTestMode)
        IncrementGuid(BaseStableGuid, data.GetStableGuidIncrementalValue());
      else
        Guid.NewGuid()
    }
  } // module
} // namespace
