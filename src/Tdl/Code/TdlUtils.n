using DotNet;
using DotNet.AstUtils;

using Nitra;
using Nitra.Declarations;
using Nitra.Runtime.GraphUtils;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Text;

namespace Tdl
{
  module TdlUtils
  {
    static RequiredProductTypeFields : list[string] = ["Name", "ReleaseName", "Version"];
    
    public NoLocation         : Location           = Location(SourceSnapshot.Default.File, NSpan(0));
    public NoFile             : ProjectSystem.File = SourceSnapshot.Default.File;
    public NoSpan             : NSpan              = NSpan(0);
    public MethodScopeFactory : ScopeFactory       = MethodScopeFactoryImpl;
    
    _methodScopeFactoryCache : Dictionary[int, bool] = Dictionary();

    public ResetMethodScopeFactoryCache() : void
    {
      _methodScopeFactoryCache.Clear();
    }

    public PlatformMakeHint(symbolCache : ISymbolCache, symbol : Platform.SetSymbol) : string
    {
      def builder = StringBuilder();
      try
      {
        symbolCache?.CacheSymbol(symbol);
        _ = builder.Append("<keyword>").HintMlEscape(symbol.Kind).Append("</keyword> ")
          .SymbolToHintMlWithSubHint(symbol)
          .Append(" = ");

        if (symbol.IsPlatformsEvaluated)
          _ = builder.Join(symbol.Platforms, HintML.SymbolToHintMlWithSubHint(_, _))
        else
          _ = builder.Append(<# <b><font color="Red">The Platforms not evaluated</font></b>.#>);

        _ = builder.MakeLocations(symbol);
      }
      catch { e => _ = builder.HintMlException(e); }
      builder.ToString()
    }
    
    public MakeDeployments(deploymentRefs : ImmutableArray[Ref[DeploymentSymbol]]) : ImmutableArray[DeploymentSymbol]
    {
      def builder = ImmutableArray.CreateBuilder();
      foreach (r in deploymentRefs)
      {
        when (r.IsSymbolEvaluated)
          builder.Add(r.Symbol);
      }
      builder.ToImmutable()
    }

    public MakeAllProducts(it : ProductSymbol, products : ImmutableArray[ProductSymbol]) : ImmutableArray[ProductSymbol]
    {
      def builder = ImmutableArray.CreateBuilder();
      def visited = HashSet();
      _ = visited.Add(it.Id);
      
      def collect(products : ImmutableArray[ProductSymbol]) : void
      {
        foreach (product in products)
        {
          unless (visited.Add(product.Id))
            continue;

          match (product)
          {
            | p   is Product.DefSymbol => builder.Add(p);
            | set is Product.SetSymbol => collect(set.Products);
            | _ => ()
          }
        }
      }

      collect(products);
      
      builder.ToImmutable()
    }

    public MakeProducts(deploymentRefs : ImmutableArray[Ref[DeclarationSymbol]]) : ImmutableArray[ProductSymbol]
    {
      def builder = ImmutableArray.CreateBuilder();
      foreach (deploymentRef in deploymentRefs)
      {
        def r = deploymentRef.Resolve();
        when (r.IsSymbolEvaluated)
          builder.Add(r.Symbol);
      }
      builder.ToImmutable()
    }

    public MakeScenarios(scenariosRefs : ImmutableArray[Ref[DeclarationSymbol]]) : ImmutableArray[ScenarioSymbol]
    {
      def builder = ImmutableArray.CreateBuilder();
      foreach (scenariosRef in scenariosRefs)
      {
        def r = scenariosRef.Resolve();
        when (r.IsSymbolEvaluated)
          builder.Add(r.Symbol);
      }
      builder.ToImmutable()
    }

    public MakeAggregateParametersScope(deployments : ImmutableArray[DeploymentSymbol]) : Scope
    {
      def visited = HashSet();
      mutable builder = UnionScopeBuilder();
      CollectDeployments(visited, ref builder, deployments);
      builder.ToScope()
    }

    private CollectDeployments(visited : HashSet[int], builder : ref UnionScopeBuilder, deployments : ImmutableArray[DeploymentSymbol]) : void
    {
      foreach (deployment in deployments)
      {
        unless (visited.Add(deployment.Id))
          return;

        match (deployment)
        {
          | s is Deployment.ScriptSymbol => UnionScopeBuilder.Add(s.ParameterScope, ref builder);
          | s is Deployment.SetSymbol => CollectDeployments(visited, ref builder, s.Deployments);
          | _ => ()
        }
      }
    }

    public MakeAggregateParametersScope(scenarios : ImmutableArray[ScenarioSymbol]) : Scope
    {
      def visited = HashSet();
      mutable builder = UnionScopeBuilder();
      CollectScenarios(visited, ref builder, scenarios);
      builder.ToScope()
    }

    private CollectScenarios(visited : HashSet[int], builder : ref UnionScopeBuilder, scenarios : ImmutableArray[ScenarioSymbol]) : void
    {
      foreach (deployment in scenarios)
      {
        unless (visited.Add(deployment.Id))
          return;

        match (deployment)
        {
          | s is Scenario.DefSymbol when s.IsDeploymentEvaluated && s.Deployment.IsAggregateParametersScopeEvaluated =>
            UnionScopeBuilder.Add(s.Deployment.AggregateParametersScope, ref builder);
          | s is Scenario.SetSymbol when s.IsScenariosEvaluated  => CollectScenarios(visited, ref builder, s.Scenarios);
          | _ => ()
        }
      }
    }

    public MakeExpected(valueOpt : DeploymentOption.Success.IAstOption) : ParsedValue[int]
    {
      if (valueOpt.HasValue) valueOpt.Value.Value else ParsedValue(valueOpt.Span.StartPos)
    }
    
    public MakeForReboot(valueOpt : DeploymentOption.ForReboot.IAstOption) : ParsedValue[int]
    {
      if (valueOpt.HasValue) valueOpt.Value.Value else ParsedValue(valueOpt.Span.StartPos)
    }

    public MakeTimeout(valueOpt : DeploymentOption.Timeout.IAstOption) : ParsedValue[string]
    {
      if (valueOpt.HasValue) TdlUtils.ConvertStringLiteral(valueOpt.Value.Value) else ParsedValue(valueOpt.Span.StartPos)
    }

    public ConvertStringLiteral(str : CSharp.StringLiteral) : ParsedValue[string]
    {
      def builder = Text.StringBuilder();
      foreach (part in str.Parts)
      {
        | Interpolation           => ()
        | InterpolationFormated   => ()
        | InterpolatedOpenEscape  => _ = builder.Append("{");
        | InterpolatedCloseEscape => _ = builder.Append("}");
        | Error                   => ()
        | SimpleEscape            => _ = builder.Append(part.Location.GetText()); // FIXME:
        | UnicodeEscape           => _ = builder.Append(part.Location.GetText()); // FIXME:
        | HexadecimalEscape       => _ = builder.Append(part.Location.GetText()); // FIXME:
        | RegulaChars             => _ = builder.Append(part.Location.GetText());
        | VerbatimEscape          => _ = builder.Append(part.Location.GetText()); // FIXME:
        | _                       => ()
      }

      ParsedValue(str.Location.Span, builder.ToString())
    }

    private ConvertDefExpr(expr : DefExpr) : Expr
    {
      match (expr)
      {
        | x is DefExpr.String                    => Expr.String(ConvertStringLiteral(x.Value).Value)
        | _ is DefExpr.True                      => Expr.True()
        | _ is DefExpr.False                     => Expr.False()
        | x is DefExpr.RealLiteral               => Expr.Real(double.Parse(x.Location.GetText()))
        | x is DefExpr.DecimalIntegerLiteral     => Expr.Integerl(int.Parse(x.Location.GetText()))
        | x is DefExpr.HexadecimalIntegerLiteral => Expr.Integerl(int.Parse(x.Location.GetText().Substring(2), NumberStyles.HexNumber))
        | x is DefExpr.Reference                 => Expr.Reference(x.Location.GetText())
        | x with loc = x.Location                => Expr.Error(Utils.Location(loc.Source.File.FullName, loc.StartPos, loc.EndPos))
      }
    }

    public MakeDefinitions(definitions : Definition.IAstList, _dependence : ImmutableArray[Ref[TypedDeclarationSymbol]]) : ImmutableArray[Def]
    {
      def builder = ImmutableArray.CreateBuilder(definitions.Count);
      foreach (definition when definition.IsSymbolRefEvaluated && definition.SymbolRef.IsSymbolEvaluated in definitions)
        builder.Add(Def(definition.SymbolRef.Symbol, ConvertDefExpr(definition.Expr)));
      builder.TryMoveToImmutable()
    }

    public MakeDefinitions(definitions : Definition.IAstList) : ImmutableArray[Def2]
    {
      def builder = ImmutableArray.CreateBuilder(definitions.Count);
      foreach (definition in definitions)
        builder.Add(Def2(definition.Reference.Text, ConvertDefExpr(definition.Expr)));
      builder.TryMoveToImmutable()
    }
    
    public Resolve(platformRefs : ImmutableArray[Ref[DeclarationSymbol]]) : ImmutableArray[Ref[PlatformSymbol]]
    {
      def builder = ImmutableArray.CreateBuilder(platformRefs.Length);
      foreach (platformRef in platformRefs)
        builder.Add(platformRef.Resolve());
      builder.TryMoveToImmutable()
    }

    public ToSymbol(it : PlatformSymbol, platforms : ImmutableArray[Ref[PlatformSymbol]]) : ImmutableArray[PlatformSymbol]
    {
      def builder = ImmutableArray.CreateBuilder(platforms.Length);
      def visited = HashSet();
      _ = visited.Add(it);
      def loccectAllPlatforms(platforms : ImmutableArray[Ref[PlatformSymbol]])
      {
        foreach (platformRef when platformRef.IsSymbolEvaluated in platforms)
        {
          unless (visited.Add(platformRef.Symbol))
            continue;
          match (platformRef.Symbol)
          {
            | s is Platform.DefSymbol => builder.Add(s);
            | s is Platform.SetSymbol => loccectAllPlatforms(s.PlatformsRefs);
            | _ => assert(false)
          }
        }
      }

      loccectAllPlatforms(platforms);

      builder.TryMoveToImmutable()
    }

    public MakeExcludedParams(baseDeploymentRefs : ImmutableArray[Ref[TypedDeclarationSymbol]]) : ImmutableArray[FormalParameterSymbol]
    {
      def builder = ImmutableArray.CreateBuilder(baseDeploymentRefs.Length);
      foreach (r in baseDeploymentRefs)
      {
        def res = r.Resolve.[FormalParameterSymbol]();
        when (res.IsSymbolEvaluated)
          builder.Add(res.Symbol);
      }
      builder.TryMoveToImmutable()
    }

    public MakeCurryingScope(scope : Scope, excludedParams : ImmutableArray[FormalParameterSymbol]) : Scope
    {
      def predicate(symbol : DeclarationSymbol) : bool
      {
        def id = symbol.Id;
        foreach (excludedParam in excludedParams)
          when (excludedParam.Id == id)
            return false;

        true
      }
      FilteringScope(scope, predicate)
    }
    
    public MakeParameterScope(scope : Scope) : Scope
    {
      FilteringScope(scope, HashSet(ParameterComparer()).Add)
    }
    
    public IsMissingRequiredOptions(options : ImmutableArray[Ref[TypedDeclarationSymbol]]) : bool
    {
      GetMissingRequiredOptionNames(options).Any()
    }

    GetMissingRequiredOptionNames(options : ImmutableArray[Ref[TypedDeclarationSymbol]]) : Seq[string]
    {
      def optionSet = HashSet();
      foreach (option when option.IsSymbolEvaluated in options)
        _ = optionSet.Add(option.Symbol.Id);

      foreach (required in ProjectSupport.RequiredScenarioParameters)
        unless (optionSet.Contains(required.Id))
          yield required.Name;
    }
    
    public GetMissingRequiredOptionMessage(options : ImmutableArray[Ref[TypedDeclarationSymbol]]) : string
    {
      string.Join(", ", GetMissingRequiredOptionNames(options))
    }

    public TryMoveToImmutable[T](this builder : ImmutableArray[T].Builder) : ImmutableArray[T]
    {
      if (builder.Capacity == builder.Count)
        builder.MoveToImmutable()
      else
        builder.ToImmutable()
    }

    MethodScopeFactoryImpl(scope : Scope) : Scope
    {
      def filter(symbol : DeclarationSymbol) : bool
      {
        mutable result;
        when (_methodScopeFactoryCache.TryGetValue(symbol.Id, out result))
          return result;
        
        def isTestMethod(m : Member.MethodSymbol) : bool
        {
          foreach (a in m.CustomAttributes)
          {
            def name = a.Name;
            when (name == "TestMethodAttribute" || name == "TestMethod" )
              return true;
          }
          false
        }
        def isTestMember(m : DeclarationSymbol) : bool
        {
          | method is Member.MethodSymbol => isTestMethod(method)
          | _                             => false
        }

        def isTestClass(c : TopClassSymbol) : bool
        {
          foreach (a in c.CustomAttributes)
          {
            def name = a.Name;
            when (name.Contains("Test") && c.Scope.GetAllSymbols().Any(isTestMember))
              return true;
          }
          false
        }

        def isNamespaceContainsTestClasses(ns : NamespaceSymbol) : bool
        {
          foreach (m when filter(m) in ns.MemberTable.GetAllSymbols())
            return true;
          false
        }

        result =
          match (symbol)
          {
            | NamespaceSymbol     as ns when isNamespaceContainsTestClasses(ns) => true
            | TopClassSymbol      as c  when isTestClass(c)                     => true
            | Member.MethodSymbol as m  when isTestMethod(m)                    => true
            | _                                                                 => false
          };

        _methodScopeFactoryCache[symbol.Id] = result;
        
        result
      }

      def filteringScope = FilteringScope(scope, filter);
      filteringScope
    }

    public HasUndefinedFieldsInProduct(type : ProductTypeSymbol, defs : ImmutableArray[Def]) : bool
    {
      CollectUndefinedFieldsInProduct(type, defs).Any()
    }
    
    public ReportProduct(type : ProductTypeSymbol, defs : ImmutableArray[Def]) : string
    {
      def undefinedFields = CollectUndefinedFieldsInProduct(type, defs).Select(x => x.Name).OrderBy(x => x);
      "The product does not have fields declared in the product type: " + string.Join(", ", undefinedFields) + "."
    }

    CollectUndefinedFieldsInProduct(type : ProductTypeSymbol, defs : ImmutableArray[Def]) : Seq[DeclarationSymbol]
    {
      def fieldSet = type.MemberTable.GetAllSymbols();
      def defSet   = defs.Select(d => d.Symbol);
      fieldSet.Except(defSet)
    }
    
    public ResolveSuiteTypeSymbol(this context : DependentPropertyEvalContext, typeRef : Ref[DeclarationSymbol]) : SuiteTypeSymbol
    {
      def makeDefaulteSuiteTypeSymbol()
      {
        def symbol = SuiteTypeSymbol();
        symbol.EvalProperties(context);
        symbol
      }

      if (typeRef == null)
        makeDefaulteSuiteTypeSymbol()
      else
      {
        def result = typeRef.Resolve();
        if (result.IsUnresolved)
          makeDefaulteSuiteTypeSymbol()
        else
          result.Symbol
      }
    }
    
    public IsMissingRequiredProductTypeFields(fields : ImmutableArray[Tdl.FieldSymbol]) : bool
    {
      def set = HashSet(RequiredProductTypeFields);
      foreach (field in fields)
        _ = set.Remove(field.Name);
      set.Count > 0
    }
    
    public GetMissingRequiredProductTypeFieldsMessage(fields : ImmutableArray[Tdl.FieldSymbol]) : string
    {
      def set = HashSet(RequiredProductTypeFields);
      foreach (field in fields)
        _ = set.Remove(field.Name);
      
      $"Missing required fields: ..$set"
    }
    
    public ReportDuplicateBarrier(this ast : IAst, context : DependentPropertyEvalContext, actions : ImmutableArray[ScenarioAction]) : void
    {
      def set = HashSet();
      foreach (b is ScenarioAction.Barrier when !set.Add(b.barrier.Id) in actions)
      {
        def loc = Location(ast.Location.Source, b.Location.StartPos, b.Location.EndPos);
        def msgs = context.GetFileData(ast.Location.Source.File.Id).GetCompilerMessage();
        msgs.ReportMessage(CompilerMessageType.Error, loc, "Multiple usage of barrier " + b.barrier.InitialName, 0);
      }
    }
    
    [Record]
    struct Edge
    {
      public From : ScenarioAction.Barrier;
      public To   : ScenarioAction.Barrier;
    }
    
    [Record]
    class Node : IGraphNode[Node]
    {
      public Barrier : BarrierSymbol;
      [RecordIgnore]
      public Connections : List[Node] implements IGraphNode[Node].Connections { get; default List(); }
    }
    
    public CheckMultiMachineScenario(this ast : IAst, context : DependentPropertyEvalContext, scenarios : ImmutableArray[ScenarioSymbol], _depend : object) : void
    {
      def edges = List();
      def nodesMap = Dictionary();
      def loop(scenario : ScenarioSymbol) : void
      {
        | Scenario.DefSymbol as d =>
          unless (d.IsActionsEvaluated)
            return;
            
          mutable prev;
          foreach (action is ScenarioAction.Barrier in d.Actions)
          {
            mutable node;
            unless (nodesMap.TryGetValue(action.barrier, out node))
            {
              node = Node(action.barrier);
              nodesMap.Add(action.barrier, node);
            }
            
            when (prev != null)
            {
              nodesMap[prev.barrier].Connections.Add(node);
              edges.Add(Edge(prev, action));
            }
            
            prev = action;
          }
        
        | Scenario.SetSymbol as s =>
          unless (s.IsScenariosEvaluated)
            return;
          foreach (scenario in s.Scenarios)
            loop(scenario);
        | _ => assert(false)
      }
      foreach (scenario in scenarios)
        loop(scenario);
        
      def groups = GraphAlgorithms.FindStronglyConnectedComponents(nodesMap.Values);
      
      foreach (group in groups)
        when (group.Nodes.Count > 1)
        {
          def symbols = HashSet();
          foreach (node in group.Nodes)
            _ = symbols.Add(node.Barrier);
            
          def barrierUsages = HashSet();
          foreach (edge in edges)
          {
            when (symbols.Contains(edge.From.barrier) && symbols.Contains(edge.To.barrier))
            {
              _ = barrierUsages.Add(edge.From);
              _ = barrierUsages.Add(edge.To);
            }
          }
          
          def filesMap           = context.Files.ToDictionary(d => d.FullName);
          def msgs               = context.GetFileData(ast.Location.Source.File.Id).GetCompilerMessage();
          def dadeLockedBarriers = group.Nodes.ToArray().Select(n => n.Barrier.Name);
          foreach (usage in barrierUsages.OrderBy(u => u.Location.File).ThenBy(u => u.Location.StartPos))
          {
            def fileData = filesMap[usage.Location.File];
            def loc      = Location(fileData.Ast.Location.Source, usage.Location.StartPos, usage.Location.EndPos);
            msgs.ReportMessage(CompilerMessageType.Error, loc, $"Barriers dadelock detected: ..$dadeLockedBarriers", 0);
          }
        }
    }

    public Convert(this location : Nitra.Location) : Tdl.Utils.Location
    {
        Tdl.Utils.Location(location.Source.File.FullName, location.StartPos, location.EndPos)
    }
  } // module
} // namespace
