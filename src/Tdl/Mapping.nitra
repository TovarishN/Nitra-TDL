using DotNet;
using Nitra;
using Nitra.Declarations;

namespace Tdl
{
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // Следующий код добавляет в шарповые идентификаторы поддержку идентификаторов в Lisp-стиле и "заковыченых"

  map syntax Grammar.Name.String    -> Declarations.Name = Nitra.Declarations.Name(this.Location, GetText(this.Body));
  map syntax Grammar.Name.ListStyle -> Declarations.Name = Nitra.Declarations.Name(this.Location, GetText(this.Body));

  map syntax Grammar.Name.String(_tag : CSharp.ImplicitNamespaceTag) -> ImplicitNamespace { this -> Name; }
  map syntax Grammar.Name.ListStyle(_tag : CSharp.ImplicitNamespaceTag) -> ImplicitNamespace { this -> Name; }

  map syntax Grammar.Reference.String    -> Declarations.Reference = Nitra.Declarations.Reference(this.Location, GetText(this.Body));
  map syntax Grammar.Reference.ListStyle -> Declarations.Reference = Nitra.Declarations.Reference(this.Location, GetText(this.Body));

  map syntax Grammar.Module -> Module
  {
    Name = Name(Location.FromStart(), Location.Source.File.FullName);
    MemberDeclarations -> Members;
  }

  //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  map syntax Grammar.MemberDeclaration -> NamespaceMember
  {
    | Open             -> UsingOpenDirective  {               QualifiedIdentifier -> NamespaceOrTypeName; }
    | Alias            -> UsingAliasDirective { Name -> Name; QualifiedIdentifier -> NamespaceOrTypeName; }
    | Platform         -> Platform.Def        { Name -> Name; }
    | PlatformSet      -> Platform.Set        { Name -> Name; Platforms.Item1 -> Platforms; }
    | DeploymentScript -> Deployment.Script
      {
        Name                                 -> Name;
        ScriptPath                           -> Path;
        FormalParameters.Item1               -> Parameters;
        DeploymentScriptBody.DefDeclarations -> Definitions;
        DeploymentScriptBody.Options         -> Options;
      }
    | DeploymentSet    -> Deployment.Set      { Name -> Name; Deployments.Item1 -> Deployments; }
    | Currying         -> Deployment.Currying { Name -> Name; Reference -> BaseDeployment; ParameterCurryings.Item1 -> CurredParameters; }
    | ProductType      -> ProductType         { Name -> Name; TypeBody.Fields -> Fields; }
    | Product          -> Product.Def         { Name -> Name; Type -> Type; ProductBody.DefDeclarations -> Definitions; }
    | ProductSet       -> Product.Set         { Name -> Name; Type -> Type; Products.Item1 -> Products; }
    | Scenario         -> Scenario.Def
      {
        Name                                    -> Name;
        ScenarioBody.Deployment.Reference       -> Deployment;
        ScenarioBody.Action                     -> Actions;
        ScenarioBody.Environments.Elems.Item1   -> Environments;
        ScenarioBody.DefDeclarations            -> Definitions;
      }
    | ScenarioSet      -> Scenario.Set { Name -> Name; Scenarios.Item1 -> Scenarios; }
    | SuiteType        -> SuiteType    { Name -> Name; TypeBody.Fields -> Fields; }
    | Suite            -> Suite
      {
        Name                         -> Name;
        None()                       -> TypeOpt;
        SuiteBody.Platform.Reference -> Platform;
        SuiteBody.Product.Reference  -> Product;
        SuiteBody.DefDeclarations    -> Definitions;
        SuiteBody.SuiteStatements    -> Statements;
      }
    | SuiteTyped       -> Suite
      {
        Name                         -> Name;
        Some(Type)                   -> TypeOpt;
        SuiteBody.Platform.Reference -> Platform;
        SuiteBody.Product.Reference  -> Product;
        SuiteBody.DefDeclarations    -> Definitions;
        SuiteBody.SuiteStatements    -> Statements;
      }
    | External -> ExternalAst { ExternalBody.Fields -> Fields; }
  }

  map syntax Grammar.DeploymentExpr -> DeploymentExpr
  {
    | Reference -> DeploymentReference { Reference -> Reference; }
    | Reboot    ->
      let timeout : CSharp.StringLiteral = Timeout in
      DeploymentReboot
      {
          Name = Name(Location, "Reboot-" + TdlUtils.ConvertStringLiteral(timeout));
          timeout -> Timeout;
      }
  }

  map syntax Grammar.ScenarioBody.Action -> Action*
  {
    | Method   -> [ Action.Method { Method.QualifiedIdentifier -> Method; } ]
    | Sequence -> SequenceActions
  }


  map syntax Grammar.ScenarioBody.SequenceAction -> Action
  {
    | Method         -> Method { Method.QualifiedIdentifier -> Method; }
    | Reboot         -> Reboot { }
    | WaitForReboot1 -> WaitForReboot { TimeSpan = ParsedValue(TimeSpan, GetText(TimeSpan)); }
    | WaitForReboot2 -> WaitForReboot { TimeSpan = ParsedValue(TimeSpan, GetText(TimeSpan)); }
  }

  map syntax Grammar.DeploymentOption -> DeploymentOption
  {
    | Success    -> Success   { Value = ParsedValue(Value.Span, int.Parse(Value.GetText())); }
    | ForReboot1 -> ForReboot { Value = ParsedValue(Value.Span, int.Parse(Value.GetText())); }
    | ForReboot2 -> ForReboot { Value = ParsedValue(Value.Span, int.Parse(Value.GetText())); }
    | Timeout    -> Timeout   { Value -> Value; }
  }

  map syntax Grammar.DefDeclaration -> Definition
  {
    Reference -> Reference;
    DefExpr   -> Expr;
  }

  map syntax Grammar.ParameterCurrying -> Definition
  {
    Reference -> Reference;
    DefExpr   -> Expr;
  }

  map syntax Grammar.DefExpr -> DefExpr
  {
    | StringLiteral             -> String                    { StringLiteral -> Value; }
    | True                      -> True                      {  }
    | False                     -> False                     {  }
    | RealLiteral               -> RealLiteral               {  }
    | DecimalIntegerLiteral     -> DecimalIntegerLiteral     {  }
    | HexadecimalIntegerLiteral -> HexadecimalIntegerLiteral {  }
    | Reference                 -> Reference                 { this.Reference -> PatameterName; }
  }

  map syntax Grammar.Field -> Field
  {
    Name    -> Name;
    AnyType -> Type;
  }

  map syntax Grammar.SuiteBody.SuiteStatement -> SuiteStatementAst
  {
    | CallTest -> CallScenario { Scenario -> Scenario; }
  }

  map syntax Grammar.ScenarioBody.Environment -> EnvironmentAst
  {
    Platform -> Platform;
    Product  -> Product;
  }

  map syntax Grammar.StringLiteral -> CSharp.StringLiteral {}

  map syntax Grammar.StringLiteral.RegularStringLiteral -> CSharp.StringLiteral { Lit }

  map syntax Grammar.StringLiteral.VerbatimStringLiteral -> CSharp.StringLiteral { Lit }
}
