namespace Tdl
{
  syntax module Grammar
  {
    using DotNet;
    using Nitra.Core;
    using CSharp.Core;
    using CSharp.CsIdentifiers;
    using CSharp.Expressions;
    using CSharp.Literals;
    using CSharp.TokenNames;
    using CSharp.TopDeclarations;
    using CSharp.Types;
    using CSharp.CS7;

    keyword regex ['A'..'Z', 'a'..'z', '_'..'_', '-'..'-']+ ['0'..'9']* rule S;

    [StartRule]
    syntax Module = MemberDeclaration*;

    regex TdlIdentifierPartCharacters = CSharp.CsIdentifiers.IdentifierPartCharacters | '-';
    regex LispIdent                   = CSharp.CsIdentifiers.IdentifierStartCharacter TdlIdentifierPartCharacters*;

    extend token Name
    {
      | String = '\"' Body=(!NotAllowedRegularStringLiteralChar Any)+ '\"'
      | ListStyle = Body=LispIdent
    }

    extend token Reference
    {
      | String = '\"' Body=(!NotAllowedRegularStringLiteralChar Any)+ '\"'
      | ListStyle = Body=LispIdent
    }

    syntax StringLiteral
    {
      | RegularStringLiteral  = Lit=RegularStringLiteral
      | VerbatimStringLiteral = Lit=VerbatimStringLiteral
    }

    syntax Parameters = "(" (FormalParameter; ","sm)* ")";

    syntax DeploymentScriptContent
    {
      | FilePath   = "script" sm Path=StringLiteral
      | Base64     = "base64" sm Data=StringLiteral nl "extension" sm Extension=StringLiteral
      | SourceCode = "source" sm Text=StringLiteral nl "extension" sm Extension=StringLiteral
      | EmbedFile  = "file"   sm Path=StringLiteral
    }

    syntax MemberDeclaration
    {
      | Alias             = "using"             sm Name sm "=" sm QualifiedIdentifier ";" nl;
      | Open              = "using"             sm QualifiedIdentifier ";" nl;
      | Platform          = "platform"          sm Name ";" nl;
      | PlatformSet       = "platform"          sm Name sm "=" sm Platforms=(Reference; "," sm)+ ";" nl;
      | DeploymentScript  = "deployment"        sm Name outline_begin_before Parameters outline_end_before nl DeploymentScriptContent nl DeploymentScriptBody;
      | DeploymentCode    = "deployment"        sm Name outline_begin_before Parameters outline_end_before nl DeploymentCodeBody;
      | DeploymentSet     = "deployment"        sm Name sm "=" sm Deployments=(DeploymentExpr; "," sm)+ ";" nl
      | Currying          = "deployment"        sm Name sm "=" sm Reference "(" (ParameterCurrying; "," sm)+ ")" ";" nl
      | DeploymentSelect  = "select" sm "deployment" sm Name "(" (Parameter; "," sm)+ ")"
                            "{" inl
                                Case*  
                            d "}" nl outline_end_before
        {
          syntax Parameter = Name;
        }

      | ProductType       = "product" sm "type" sm Name nl TypeBody;
      | Product           = "product"           sm Name sm ":" Type=Reference nl ProductBody;
      | ProductSet        = "product"           sm Name sm ":" Type=Reference sm "=" sm Products=(Reference; "," sm)+ ";" nl;
      | Scenario          = "scenario"          sm Name Parameters? nl ScenarioBody;
      | ScenarioSet       = "scenario"          sm Name sm "=" sm Scenarios=(Reference; "," sm)+ ";" nl;
      | ScenarioGenerator = "scenario"          sm Name sm "=" sm From+ sm "select" sm SelectScenario ";" nl;
      | ParallelScenario  = Parallel="parallel" sm "scenario" sm Name sm "=" sm Scenarios=(Reference; "," sm)+ ";" nl;
      | SuiteType         = "suite" sm "type"   sm Name nl TypeBody;
      | Suite             = "suite"             sm Name nl SuiteBody;
      | SuiteTyped        = "suite"             sm Name sm ":" Type=Reference nl SuiteBody;
      | SuiteList         = "suite"             sm Name sm "=" sm Suites=(Reference; "," sm)+ ";" nl;
      | SuiteGenerator    = "suite"             sm Name sm "=" sm From+ sm "select" sm SuiteScenario ";" nl;
      | External          = "external"          sm ExternalBody;
      | Barrier           = "barrier"           sm Name "timeout" sm Timeout=StringLiteral ";" nl;
      | Entity            = "entity" sm Name nl EntityBody;
    }

    syntax SuiteScenario = outline_begin_before
      "{" inl
          Entity?
          Platform
          Product
          DefDeclaration*
          SuiteStatement+
    d "}" nl outline_end_before
    {
      syntax Entity   = "entity" sm Reference ";" nl;
      syntax Platform = "platform" sm Reference ";" nl;
      syntax Product  = "product"  sm Reference ";" nl;
    }

    syntax SuiteBody = outline_begin_before "{" inl Entity? Platform Product DefDeclaration* SuiteStatement+ d "}" nl outline_end_before
    {
      syntax Entity   = "entity" sm Reference ";" nl;
      syntax Platform = "platform" sm Reference ";" nl;
      syntax Product  = "product"  sm Reference ";" nl;
    }

    syntax SuiteStatement
    {
      | CallTest = Scenario=Reference "(" ")" ";" nl;
    }

    syntax EntityBody = outline_begin_before "{" inl DefDeclaration* d "}" nl outline_end_before;

    syntax Case = "|" sm (Value; "," sm)+ sm "=>" Reference nl
    {
      syntax Value
      {
        | String = StringLiteral
        | Wildcard = "_"
      }
    }

    syntax From = "from" VarDecl "in" List=DefExpr
    {
      syntax VarDecl
      {
        | Name
        | Tuple = "(" (Name; "," sm)+ ")"
      }
    }

    syntax SelectScenario = outline_begin_before 
                            "{" inl 
                                Deployment nl 
                                "environments" sm "(" Platform=Reference "," sm Product=Reference ")" ";" nl
                                Method nl
                                DefDeclaration* 
                          d "}" nl outline_end_before
    {
      syntax Deployment   = "deployment" sm Reference ";" nl;
    }

    syntax Environments    = "environments" sm Elems=(Environment; "," sm; ?)+ ";" nl;
    syntax Environment     = "(" Platform=Reference "," sm Product=Reference ")";
    syntax Method          = "method" sm QualifiedIdentifier MaxRebootsCountOpt=MaxRebootsCount? ";" nl;
    syntax Config          = "config" sm Path=StringLiteral MaxRebootsCount? ";" nl;
    syntax GTest           = "gtest"  sm Name=StringLiteral Arguments=StringLiteral* MaxRebootsCount? ";" nl;
    syntax Apk             = "apk"    sm Name=StringLiteral Filter? "runner" RunnerPath=StringLiteral MaxRebootsCount? ";" nl
    {
      syntax Filter = "filter" Value=StringLiteral;
    }
    syntax Script       = "script" sm Name=StringLiteral Arguments=StringLiteral* Environments? MaxRebootsCount? ";" nl
    {
      syntax Environments = "(" Defs=(DefEnv; ", ")+ ")";
    }
    syntax Action
    {
      | Method
      | Config
      | Script
      | GTest
      | Apk
      | Sequence = "sequence" sm  "{" inl SequenceAction* d "}" nl outline_end_before
    }
    regex TimeSpan = DecimalDigit DecimalDigit ":" DecimalDigit DecimalDigit ":" DecimalDigit DecimalDigit | "";
    syntax SequenceAction
    {
      | Method
      | Config
      | GTest
      | Apk
      | Script
      | Login           = "login" sm User=StringLiteral sm Password=StringLiteral ";" nl;
      | Logoff          = "logoff" ";" nl;
      | LockWorkstation = "lock-workstation" ";" nl;
      | Reboot          = "reboot" ";"
      | WaitForReboot1  = "wait" sm  "for" sm "reboot" sm TimeSpan ";"
      | WaitForReboot2  = "wait-for-reboot"            sm TimeSpan ";"
      | Barrier         = "barrier" sm Reference ";"
    }

    syntax DeploymentExpr
    {
      | Reference
      | Reboot = "reboot" Timeout=StringLiteral
    }

    syntax ParameterCurrying = Reference ":" sm DefExpr;

    syntax ScenarioBody = outline_begin_before "{" inl Filter? Deployment Environments Action DefDeclaration* d "}" nl outline_end_before
    {
      syntax Deployment   = "deployment" sm Reference ";" nl;
      syntax Filter = "filter" Condition=Expression ";" nl;
    }

    syntax ProductBody = outline_begin_before "{" inl DefDeclaration* d "}" nl outline_end_before;

    syntax TypeBody = outline_begin_before "{" inl Field* d "}" nl outline_end_before;

    syntax ExternalBody = outline_begin_before "{" inl Field* d "}" nl outline_end_before;

    syntax Field = AnyType sm Name ";" nl;
    
    syntax DeploymentScriptBody = outline_begin_before "{" inl DefDeclaration* Options=DeploymentOption* d "}" nl outline_end_before;

    syntax DeploymentOption
    {
      | Success    = "expected"                      sm Value=DecimalIntegerLiteral ";" nl;
      | ForReboot1 = "expected" sm "for" sm "reboot" sm Value=DecimalIntegerLiteral ";" nl;
      | ForReboot2 = "expected-for-reboot"           sm Value=DecimalIntegerLiteral ";" nl;
      | Timeout    = "timeout"                       sm Value=StringLiteral ";" nl;
    }

    syntax DeploymentCodeBody = outline_begin_before "{" inl Commands=CommandCall* Options=DeploymentOption* d "}" nl outline_end_before;

    syntax CommandCall = Command=QualifiedIdentifier "(" Arguments=(CommandCallArgument; ","sm)* ")" ";" nl;

    syntax CommandCallArgument
    {
      | Input  = ParameterName=Reference ":" sm Value=DefExpr
      | Output = ParameterName=Reference ":" sm "out" sm "var" sm VariableName=Name
      | InputShort = Reference
    }

    syntax DefDeclaration = Reference sm "=" sm DefExpr ";" nl;
    syntax DefEnv         = Reference sm "=" sm DefExpr;

    syntax DefExpr
    {
      | ListLiteral = "[" Elements=(DefExpr; "," sm; ?)* "]"
      | StringLiteral
      | "true"
      | "false"
      | RealLiteral;
      | DecimalIntegerLiteral     = Lit=DecimalIntegerLiteral
      | HexadecimalIntegerLiteral = Lit=HexadecimalIntegerLiteral
      | Reference
      | Tuple = "(" Items=(DefExpr; "," sm; ?)+ ")"
      //| InterpolatedRegularStringLiteral  = Lit=InterpolatedRegularStringLiteral
      //| InterpolatedVerbatimStringLiteral = Lit=InterpolatedVerbatimStringLiteral
    precedence MemberAccess:
      | MemberAccess = Expr=DefExpr "." Member=Reference
    }

    syntax MaxRebootsCount = sm "max-reboots" sm Value=DecimalIntegerLiteral;
  }
}
