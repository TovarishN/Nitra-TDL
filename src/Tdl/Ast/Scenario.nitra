using DotNet;
using DotNet.AstUtils;

using Nitra;
using Nitra.Declarations;

using System;
using System.Collections.Immutable;

namespace Tdl
{
  abstract declaration Scenario : NamespaceMember, UsedDeclaration
  {
    symbol
    {
    stage 3:
      in AggregateParametersScope : Scope;
    }
    
    CheckForRecursionScenario(context, Symbol, Symbol.AggregateParametersScope);

    unless (Symbol.IsUsed)
      Name.Warning(context, "Unused scenario.");

    | Def
      {
        symbol
        {
          in Defs           : ImmutableArray[Def];
        stage 1:            
          in Actions        : ImmutableArray[ScenarioAction];
          in Deployment     : DeploymentSymbol;
          in Environments   : ImmutableArray[Environment];
          in ParallelSetOpt : Scenario.SetSymbol;

          Kind           = "scenario";
          SpanClass      = TdlLang.ScenarioSpanClass;
          IsSameIdentity = candidate is Tdl.Scenario;
        }
      stage 1:
        out DeploymentRef          : Ref[DeploymentSymbol];
        out MethodConditionalScope : ValueOption[Scope] = if (TdlTypingSettings.IsMethodTypingEnabled) VSome(Scope) else VNone();

        Symbol.AggregateParametersScope = Symbol.Deployment.AggregateParametersScope;

        Actions.Scope                   = MethodConditionalScope.Value;
        Symbol.Actions                  = Actions.ScenarioActions;

        Deployment.Scope                = Scope;
        DeploymentRef                   = Deployment.Ref.Resolve();
        Symbol.Deployment               = DeploymentRef.Symbol;

        Environments.Scope              = Scope;
        Symbol.Environments             = Environments.Environment;

        Definitions.Scope               = ProjectSupport.ExternalSymbolTable;
        Definitions.DefinitionScope     = ProjectSupport.ScenarioParameterScope;
        Symbol.Defs                     = TdlUtils.MakeDefinitions(Definitions, Definitions.SymbolRef);

        ReportDuplicateBarrier(context, Symbol.Actions);

        when (TdlUtils.IsMissingRequiredOptions(Definitions.SymbolRef))
          Name.Error(context, $"Missing required option: $(TdlUtils.GetMissingRequiredOptionMessage(Definitions.SymbolRef))");

        CheckOptionForDuplicates(context, Definitions.SymbolRef);

        Deployment   : Reference;
        Environments : EnvironmentAst*;
        Definitions  : Definition*;
        Actions      : Action*;
      }
    | Set
      {
        symbol
        {
        stage 1:
          in Scenarios      : ImmutableArray[ScenarioSymbol];
          in IsMultiMachine : bool;
          in MultiMachineId : Guid;
          in BarriersCount  : list[BarrierSymbol * int];

          Kind           = "scenario set";
          SpanClass      = TdlLang.ScenarioSpanClass;
          IsSameIdentity = candidate is Tdl.Scenario;
        }

        Scenarios.Scope                 = Scope;
        Symbol.Scenarios                = TdlUtils.MakeScenarios(Scenarios.Ref);
        Symbol.AggregateParametersScope = TdlUtils.MakeAggregateParametersScope(Symbol.Scenarios);
        Symbol.MultiMachineId           = if (MultiMachineId.HasValue) MultiMachineId.Value else Guid.Empty;
        Symbol.IsMultiMachine           = Symbol.MultiMachineId != Guid.Empty;

        when (MultiMachineId.HasValue)
          CheckMultiMachineScenario(context, Symbol.Scenarios, Symbol.AggregateParametersScope);

        CheckUniquenessOfScenarios(context, Symbol, Symbol.AggregateParametersScope);
        SetUsed(Symbol.Scenarios, Symbol.IsUsed);

        MultiMachineId : Guid;
        Scenarios      : Reference*;
      }
    | Generator : Container
      {
        symbol
        {
          in Defs       : ImmutableArray[Def];
          in Deployment : TypedSymbol;
          in Method     : TypedSymbol;
          in Platform   : TypedSymbol;
          in Product    : TypedSymbol;
        stage 3:
          in Froms      : ImmutableArray[Code.From];

          Scope          = MemberTable;
          Kind           = "scenario generator";
          IsSameIdentity = candidate is Tdl.Scenario;
          SpanClass      = TdlLang.ScenarioSpanClass;
        }

      stage 1:
        out DeploymentRef : Ref[TypedSymbol];
        out MethodRef     : Ref[TypedSymbol];
        out PlatformRef   : Ref[TypedSymbol];
        out ProductRef    : Ref[TypedSymbol];

        Froms.Scope                     = Scope;
        Froms.ContainingTable           = Symbol.MemberTable;
        Deployment.Scope                = Scope.HideWith(Symbol.MemberTable);
        Platform.Scope                  = Deployment.Scope;
        Product.Scope                   = Deployment.Scope;
        Method.Scope                    = Deployment.Scope;
        Definitions.DefinitionScope     = ProjectSupport.ScenarioParameterScope;
        Definitions.Scope               = ProjectSupport.ExternalSymbolTable;

        DeploymentRef                   = Deployment.Ref.Resolve();
        MethodRef                       = Method.Ref.Resolve();
        PlatformRef                     = Platform.Ref.Resolve();
        ProductRef                      = Product.Ref.Resolve();

        Symbol.Deployment               = DeploymentRef.Symbol;
        Symbol.Method                   = MethodRef    .Symbol;
        Symbol.Platform                 = PlatformRef  .Symbol;
        Symbol.Product                  = ProductRef   .Symbol;
        Symbol.Defs                     = TdlUtils.MakeDefinitions(Definitions, Definitions.SymbolRef);
        Symbol.Froms                    = await TdlUtils.MakeFroms(Froms);
        Symbol.AggregateParametersScope = await TdlUtils.MakeAggregateParametersScope(Symbol.Deployment, Symbol.Froms);
        
        Deployment.CheckExpected(context, context.ToTdlContext().DeploymentType, DeploymentRef.Symbol.Type);
        Method.    CheckExpected(context, context.ToTdlContext().MethodType,     MethodRef.Symbol.Type);
        Platform.  CheckExpected(context, context.ToTdlContext().PlatformType,   PlatformRef.Symbol.Type);
        Product.   CheckExpected(context, context.ToTdlContext().ProductType,    ProductRef.Symbol.Type);

        Froms        : From*;
        Deployment   : Reference;
        Platform     : Reference;
        Product      : Reference;
        Definitions  : Definition*;
        Method       : QualifiedReference;
      }
  } // Scenario
}
