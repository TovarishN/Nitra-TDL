using DotNet;
using DotNet.AstUtils;

using Nitra;
using Nitra.Declarations;

namespace Tdl
{
  abstract ast DefExpr : BindableAst
  {
  stage 2:
    in  ExpectedType : TypeSymbol;
    out Type         : TypeSymbol;

    unless (Type.SubtypeUnify(ExpectedType))
      Error(context, $"Expected $(self.ExpectedType), got $(self.Type)");

    | ListLiteral
      {
      stage 2:
        out ElementType : TypeSymbol;

        ElementType = RequiredTypeParam1(context, Type, "System.Collections.Generic.IEnumerable", context.CreateFreeTypeVar());
        Provide(context, Type, ExpectedType);
        Elements.ExpectedType = ElementType;
        Elements.Scope = Scope;
        Type = context.CreateFreeTypeVar();

        Elements : DefExpr*;
      }
    | String                    { Type = context.GetStringType(); Value : CSharp.StringLiteral; }
    | True                      { Type = context.GetBooleanType(); }
    | False                     { Type = context.GetBooleanType(); }
    | RealLiteral               { Type = context.GetDoubleType(); }
    | DecimalIntegerLiteral     { Type = context.GetInt32Type(); }
    | HexadecimalIntegerLiteral { Type = context.GetInt32Type(); }
    | Reference
      {
        out TypedRef : Ref[TypedDeclarationSymbol];
        
        ParameterName.Scope = Scope;
        TypedRef            = ParameterName.Ref.Resolve();
        Type                = TypedRef.Symbol.Type;

        ParameterName : Declarations.Reference;
      }
    | MemberAccess
      {
        out TypedRef : Ref[TypedDeclarationSymbol];
        
        TypedRef     = Member.Ref.Resolve();
        Type         = TypedRef.Symbol.Type;
        Expr.Scope   = Scope;
        Member.Scope = Expr.Type.Scope;

        Expr   : DefExpr;
        Member : Declarations.Reference;
      }
  }
}
