using DotNet;
using DotNet.AstUtils;

using Nitra;
using Nitra.Declarations;

using System;
using System.Collections.Immutable;
using System.Linq;

namespace Tdl
{
  abstract ast Action : BindableAst
  {
    out ScenarioActions : ScenarioAction;

    | Script
      {
        ScenarioActions = ScenarioAction.Script(Name.Location.Convert(), TdlUtils.ConvertStringLiteral(Name), 
          Arguments.Select(TdlUtils.ConvertStringLiteral).ToImmutableArray(), TdlUtils.MakeDefinitions(Definitions), Value);

        Value       : ParsedValue[int];
        Name        : CSharp.StringLiteral;
        Arguments   : CSharp.StringLiteral*;
        Definitions : Definition*;
      }

    | Config
      {
        ScenarioActions = ScenarioAction.Config(Path.Location.Convert(), TdlUtils.ConvertStringLiteral(Path), Value);

        Value                      : ParsedValue[int];
        Path                       : CSharp.StringLiteral;
      }

    | Method
      {
      stage 1:
        out MethodRef : Ref[Member.MethodSymbol];

        Method.NameScopeFactory = TdlUtils.MethodScopeFactory;
        Method.Scope            = Scope;
        MethodRef               = Method.Ref.Resolve();
        ScenarioActions         = ScenarioAction.Method(Method.Location.Convert(), MethodRef.Symbol, Value);

        Value  : ParsedValue[int];
        Method : QualifiedReference;
      }
    | Reboot        { ScenarioActions = ScenarioAction.Reboot(this.Location.Convert()); }
    | WaitForReboot
      {
        ScenarioActions = ScenarioAction.WaitForReboot(this.Location.Convert(), TimeSpan.Value);

        TimeSpan : ParsedValue[string];
      }
    | Barrier
      {
        out BarrierRef : Ref[BarrierSymbol] = Reference.Ref.Resolve();

        Reference.Scope = Scope;
        ScenarioActions = ScenarioAction.Barrier(Reference.Location.Convert(), BarrierRef.Symbol);

        Reference : Reference;
      }
  }
}
