using DotNet;
using DotNet.AstUtils;

using Nitra;
using Nitra.Declarations;

using System;
using System.Collections.Immutable;
using System.Linq;

namespace Tdl
{
  abstract ast Action : BindableAst
  {
  stage 2:
    out ScenarioActions : ScenarioAction;

    | Script
      {
        ScenarioActions = ScenarioAction.Script(Name.Location, TdlUtils.ConvertStringLiteral(Name), 
          Arguments.Select(TdlUtils.ConvertStringLiteral).ToImmutableArray(), TdlUtils.MakeDefinitions(Definitions, Definitions.SymbolRef), MaxRebootsCountOpt);

        Name               : CSharp.StringLiteral;
        Arguments          : CSharp.StringLiteral*;
        Definitions        : Definition*;
        MaxRebootsCountOpt : ParsedValue[int];
      }

    | Config
      {
        ScenarioActions = ScenarioAction.Config(Path.Location, TdlUtils.ConvertStringLiteral(Path), MaxRebootsCountOpt);

        MaxRebootsCountOpt : ParsedValue[int];
        Path               : CSharp.StringLiteral;
      }

    | GTest
      {
        ScenarioActions = ScenarioAction.GTest(Name.Location, TdlUtils.ConvertStringLiteral(Name), 
          Arguments.Select(TdlUtils.ConvertStringLiteral).ToImmutableArray(), MaxRebootsCountOpt);

        Name               : CSharp.StringLiteral;
        Arguments          : CSharp.StringLiteral*;
        MaxRebootsCountOpt : ParsedValue[int];
      }

    | Apk
      {
        ScenarioActions = ScenarioAction.Apk(Name.Location, TdlUtils.ConvertStringLiteral(Name), 
          FilterOpt.ConvertStringLiteral(), TdlUtils.ConvertStringLiteral(RunnerPath), MaxRebootsCountOpt);

        Name               : CSharp.StringLiteral;
        FilterOpt          : CSharp.StringLiteral?;
        RunnerPath         : CSharp.StringLiteral;
        MaxRebootsCountOpt : ParsedValue[int];
      }

    | Login
      {
        ScenarioActions = TdlUtils.CreateLoginAction(context, this.Location, User, Password);

        User               : CSharp.StringLiteral;
        Password           : CSharp.StringLiteral;
      }

    | Logoff          { ScenarioActions = ScenarioAction.Logoff(this.Location); }
    | LockWorkstation { ScenarioActions = ScenarioAction.LockWorkstation(this.Location); }
    | Method
      {
      stage 1:
        out MethodRef : Ref[Member.MethodSymbol];

        Method.NameScopeFactory = context.GetMethodScopeFactory();
        Method.Scope            = Scope;
        MethodRef               = Method.Ref.Resolve();
        ScenarioActions         = await TdlUtils.MakeMethodAction(Method, MethodRef.Symbol, MaxRebootsCountOpt, BinariesFolderOpt);

        Method             : QualifiedReference;
        MaxRebootsCountOpt : ParsedValue[int];
        BinariesFolderOpt  : CSharp.StringLiteral?;

        when (!(Method is QualifiedReference.Qualified))
          Method.Error(context, "Invalid method reference. Only qualified method references supported, e.g.: MyType.MyMethod.");
      }
    | Reboot        { ScenarioActions = ScenarioAction.Reboot(this.Location); }
    | WaitForReboot
      {
        ScenarioActions = ScenarioAction.WaitForReboot(this.Location, TimeSpan.Value);

        TimeSpan : ParsedValue[string];
      }
    | Barrier
      {
        out BarrierRef : Ref[BarrierSymbol] = Reference.Ref.Resolve();

        Reference.Scope = Scope;
        ScenarioActions = ScenarioAction.Barrier(Reference.Location, BarrierRef.Symbol);

        Reference : Reference;
      }
  }
}
