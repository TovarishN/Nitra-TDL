using DotNet;
using DotNet.AstUtils;

using Nitra;
using Nitra.Declarations;

using System;
using System.Collections.Immutable;

namespace Tdl
{
  abstract ast Action : BindableAst
  {
    out ScenarioActions : ScenarioAction;

    | Config
      {
        ScenarioActions = ScenarioAction.Config(Path.Location.Convert(), TdlUtils.ConvertStringLiteral(Path), 
          if (ArtifactsCollectionTimeout.HasValue) ArtifactsCollectionTimeout.Value else null);

        Path                       : CSharp.StringLiteral;
        ArtifactsCollectionTimeout : ParsedValue[TimeSpan];
      }

    | Method
      {
      stage 1:
        out MethodRef : Ref[Member.MethodSymbol];

        Method.NameScopeFactory = TdlUtils.MethodScopeFactory;
        Method.Scope            = Scope;
        MethodRef               = Method.Ref.Resolve();
        ScenarioActions         = ScenarioAction.Method(Method.Location.Convert(), MethodRef.Symbol);

        Method : QualifiedReference;
      }
    | Reboot        { ScenarioActions = ScenarioAction.Reboot(this.Location.Convert()); }
    | WaitForReboot
      {
        ScenarioActions = ScenarioAction.WaitForReboot(this.Location.Convert(), TimeSpan.Value);

        TimeSpan : ParsedValue[string];
      }
    | Barrier
      {
        out BarrierRef : Ref[BarrierSymbol] = Reference.Ref.Resolve();

        Reference.Scope = Scope;
        ScenarioActions = ScenarioAction.Barrier(Reference.Location.Convert(), BarrierRef.Symbol);

        Reference : Reference;
      }
  }
}
